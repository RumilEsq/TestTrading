<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Advanced Live Trading Signal Bot - Adaptive Strategy Detection</title>
<script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  
  body { 
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
    background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 50%, #0f0f0f 100%);
    color: #e0e0e0; 
    min-height: 100vh;
    padding: 20px;
  }
  
  .main-container {
    max-width: 1400px;
    margin: 0 auto;
  }
  
  .header {
    text-align: center;
    margin-bottom: 30px;
    padding: 20px;
    background: linear-gradient(45deg, #1a1a1a, #2a2a2a);
    border-radius: 20px;
    border: 1px solid #333;
    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
  }
  
  .header h1 { 
    color: #00eaff; 
    font-size: 2.2em;
    margin-bottom: 10px;
    text-shadow: 0 0 20px rgba(0,234,255,0.3);
    font-weight: 700;
  }
  
  .layout { 
    display: grid;
    grid-template-columns: 1fr 400px;
    gap: 20px;
    margin-bottom: 20px;
  }
  
  .main-panel {
    background: linear-gradient(145deg, #1a1a1a, #252525);
    padding: 25px;
    border-radius: 20px;
    box-shadow: 0 15px 35px rgba(0,0,0,0.2);
    border: 1px solid #333;
  }
  
  .controls-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 15px;
    margin-bottom: 25px;
  }
  
  .control-group {
    background: rgba(0,0,0,0.3);
    padding: 15px;
    border-radius: 12px;
    border: 1px solid #444;
  }
  
  label { 
    display: block; 
    margin-bottom: 8px;
    color: #00eaff;
    font-weight: 600;
    font-size: 14px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  
  select, input { 
    width: 100%; 
    padding: 12px 15px; 
    border-radius: 10px; 
    border: 2px solid #333; 
    background: linear-gradient(145deg, #0f0f0f, #1a1a1a); 
    color: #fff;
    font-size: 15px;
    transition: all 0.3s ease;
  }
  
  select:focus, input:focus {
    outline: none;
    border-color: #00eaff;
    box-shadow: 0 0 15px rgba(0,234,255,0.2);
  }
  
  .buttons-container {
    display: flex;
    flex-wrap: wrap;
    gap: 15px;
    justify-content: center;
    margin: 25px 0;
  }
  
  button { 
    padding: 15px 25px; 
    font-size: 15px; 
    font-weight: 600;
    border: none; 
    border-radius: 12px; 
    cursor: pointer; 
    transition: all 0.3s ease;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    position: relative;
    overflow: hidden;
  }
  
  button::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
    transition: left 0.5s;
  }
  
  button:hover::before {
    left: 100%;
  }
  
  #start-btn { background: linear-gradient(45deg, #8f4dff, #b366ff); color: white; }
  #stop-btn { background: linear-gradient(45deg, #ff3d3d, #ff6b6b); color: white; }
  #backtest-btn { background: linear-gradient(45deg, #ffaa33, #ffcc66); color: #111; }
  #unlock-btn { background: linear-gradient(45deg, #00ff66, #33ff88); color: black; display: none; }
  
  button:hover { transform: translateY(-2px); box-shadow: 0 8px 25px rgba(0,0,0,0.3); }
  
  .signal-display {
    background: rgba(0,0,0,0.4);
    padding: 20px;
    border-radius: 15px;
    margin: 25px 0;
    border: 2px solid #333;
    text-align: center;
  }
  
  #signal-type { 
    font-size: 2.5em; 
    font-weight: 800;
    margin-bottom: 15px;
    text-shadow: 0 0 20px currentColor;
  }
  
  #signal-type.buy { color: #00ff99; }
  #signal-type.sell { color: #ff4444; }
  #signal-type.hold { color: #999; }
  
  .signal-info {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 15px;
    margin-top: 20px;
  }
  
  .signal-info p {
    background: rgba(0,0,0,0.3);
    padding: 10px;
    border-radius: 8px;
    font-size: 14px;
    border: 1px solid #444;
  }
  
  .confidence-bar {
    width: 100%; 
    background: #333;
    border-radius: 10px; 
    margin: 20px 0; 
    height: 30px; 
    position: relative;
    overflow: hidden;
  }
  
  .confidence-fill {
    height: 100%; 
    border-radius: 10px; 
    background: linear-gradient(90deg, #ff4444, #ffaa33, #00ff99); 
    text-align: center; 
    line-height: 30px; 
    font-size: 14px; 
    color: black;
    font-weight: 700;
    transition: width 0.5s ease;
  }
  
  /* RIGHT SIDEBAR */
  .sidebar {
    display: flex;
    flex-direction: column;
    gap: 20px;
  }
  
  .signals-feed {
    background: linear-gradient(145deg, #1a1a1a, #252525);
    border-radius: 20px;
    padding: 20px;
    border: 1px solid #333;
    box-shadow: 0 15px 35px rgba(0,0,0,0.2);
    flex: 1;
    min-height: 500px;
  }
  
  .signals-feed h3 {
    color: #00eaff;
    margin-bottom: 20px;
    font-size: 1.4em;
    text-align: center;
    border-bottom: 2px solid #333;
    padding-bottom: 15px;
  }
  
  .signals-container {
    max-height: 450px;
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: #00eaff #1a1a1a;
  }
  
  .signals-container::-webkit-scrollbar { width: 8px; }
  .signals-container::-webkit-scrollbar-track { background: #1a1a1a; border-radius: 10px; }
  .signals-container::-webkit-scrollbar-thumb { background: #00eaff; border-radius: 10px; }
  
  .signal-card {
    background: linear-gradient(145deg, #222, #2a2a2a);
    padding: 15px;
    margin-bottom: 15px;
    border-radius: 12px;
    border: 1px solid #333;
    transition: all 0.3s ease;
    position: relative;
  }
  
  .signal-card::before {
    content: '';
    position: absolute;
    left: 0;
    top: 0;
    bottom: 0;
    width: 4px;
    border-radius: 12px 0 0 12px;
  }
  
  .signal-card.buy::before { background: linear-gradient(180deg, #00ff99, #33ffaa); }
  .signal-card.sell::before { background: linear-gradient(180deg, #ff4444, #ff6666); }
  .signal-card.hold::before { background: linear-gradient(180deg, #999, #bbb); }
  
  .signal-card.latest { 
    transform: scale(1.02);
    box-shadow: 0 0 20px rgba(0,234,255,0.3);
    border-color: #00eaff;
  }
  
  .signal-header {
    font-weight: 700;
    margin-bottom: 8px;
    font-size: 1.1em;
    color: #00eaff;
  }
  
  .signal-meta {
    font-size: 12px;
    color: #aaa;
    margin-bottom: 10px;
  }
  
  .signal-details {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
    font-size: 13px;
  }
  
  .signal-details div {
    background: rgba(0,0,0,0.3);
    padding: 5px 8px;
    border-radius: 6px;
  }
  
  .status-panel {
    background: linear-gradient(145deg, #1a1a1a, #252525);
    border-radius: 20px;
    padding: 20px;
    border: 1px solid #333;
    box-shadow: 0 15px 35px rgba(0,0,0,0.2);
    text-align: center;
  }
  
  .status-panel h4 {
    color: #00eaff;
    margin-bottom: 15px;
    font-size: 1.2em;
  }
  
  .status-info {
    display: flex;
    justify-content: space-between;
    margin-bottom: 10px;
  }
  
  /* CHART AND TABLE SECTION */
  .bottom-section {
    margin-top: 30px;
  }
  
  .section-tabs {
    display: flex;
    margin-bottom: 20px;
    background: rgba(0,0,0,0.3);
    border-radius: 12px;
    padding: 5px;
  }
  
  .tab-button {
    flex: 1;
    padding: 12px;
    background: transparent;
    border: none;
    color: #aaa;
    cursor: pointer;
    border-radius: 8px;
    transition: all 0.3s ease;
  }
  
  .tab-button.active {
    background: linear-gradient(45deg, #00eaff, #0099cc);
    color: white;
  }
  
  .tab-content {
    background: linear-gradient(145deg, #1a1a1a, #252525);
    border-radius: 20px;
    padding: 25px;
    border: 1px solid #333;
    box-shadow: 0 15px 35px rgba(0,0,0,0.2);
  }
  
  table {
    width: 100%;
    border-collapse: collapse;
    font-size: 14px;
    margin-top: 20px;
  }
  
  table, th, td { border: 1px solid #444; }
  
  th, td { 
    padding: 12px 8px;
    text-align: center;
  }
  
  th { 
    background: linear-gradient(145deg, #222, #333);
    color: #00eaff;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  
  tr:nth-child(even) { background: rgba(255,255,255,0.02); }
  tr:hover { background: rgba(0,234,255,0.1); }
  
  #chart { 
    width: 100%; 
    height: 500px; 
    margin-top: 20px;
    border-radius: 15px;
    overflow: hidden;
  }
  
  #backtest-results { 
    margin-top: 20px; 
    background: rgba(0,0,0,0.2); 
    padding: 20px; 
    border-radius: 15px; 
    display: none; 
    text-align: left;
    border: 1px solid #333;
  }
  
  .stat { 
    display: inline-block; 
    min-width: 150px; 
    margin-right: 20px;
    background: rgba(0,0,0,0.3);
    padding: 15px;
    border-radius: 10px;
    text-align: center;
    border: 1px solid #444;
    margin-bottom: 15px;
  }
  
  .stat strong {
    display: block;
    color: #00eaff;
    margin-bottom: 5px;
    font-size: 14px;
  }
  
  .stat div {
    font-size: 18px;
    font-weight: 700;
  }
  
  /* NEW: Active Trade Panel */
  .active-trade-panel {
    background: linear-gradient(145deg, #1a1a1a, #252525);
    border-radius: 20px;
    padding: 20px;
    border: 1px solid #333;
    box-shadow: 0 15px 35px rgba(0,0,0,0.2);
    text-align: center;
  }
  
  .active-trade-panel h4 {
    color: #00eaff;
    margin-bottom: 15px;
    font-size: 1.2em;
  }
  
  .trade-status {
    padding: 10px;
    border-radius: 8px;
    margin-bottom: 15px;
    font-weight: 600;
  }
  
  .trade-status.active {
    background: rgba(0, 255, 0, 0.1);
    border: 1px solid #00ff00;
    color: #00ff00;
  }
  
  .trade-status.inactive {
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid #cccccc;
    color: #cccccc;
  }
  
  .trade-details {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
    font-size: 13px;
    margin-top: 15px;
  }
  
  .trade-details div {
    background: rgba(0,0,0,0.3);
    padding: 8px;
    border-radius: 6px;
  }
  
  /* Strategy Indicator */
  .strategy-indicator {
    display: inline-block;
    padding: 5px 12px;
    border-radius: 20px;
    font-size: 12px;
    font-weight: 600;
    margin-left: 10px;
  }
  
  .strategy-enhanced { background: #00eaff; color: black; }
  .strategy-crt { background: #ffaa33; color: black; }
  .strategy-orb { background: #ff44aa; color: white; }
  .strategy-smc { background: #00ff99; color: black; }
  .strategy-auto { background: #8f4dff; color: white; }
  
  /* Error and Status Indicators */
  .error-panel {
    background: linear-gradient(145deg, #2a1a1a, #3a2525);
    border: 1px solid #ff4444;
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    display: none;
  }
  
  .error-panel.show {
    display: block;
    animation: fadeIn 0.5s ease;
  }
  
  .error-header {
    color: #ff4444;
    font-weight: bold;
    margin-bottom: 10px;
    display: flex;
    align-items: center;
    gap: 10px;
  }
  
  .error-details {
    font-size: 12px;
    color: #ff9999;
    margin-top: 8px;
  }
  
  .recovery-status {
    background: linear-gradient(145deg, #1a2a1a, #253a25);
    border: 1px solid #00ff00;
    border-radius: 10px;
    padding: 10px;
    margin: 10px 0;
    display: none;
  }
  
  .recovery-status.show {
    display: block;
    animation: fadeIn 0.5s ease;
  }
  
  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(-10px); }
    to { opacity: 1; transform: translateY(0); }
  }
  
  /* Responsive Design */
  @media (max-width: 1200px) {
    .layout {
      grid-template-columns: 1fr;
    }
    
    .controls-grid {
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    }
  }
  
  @media (max-width: 768px) {
    .header h1 { font-size: 1.8em; }
    .buttons-container { flex-direction: column; }
    .signal-info { grid-template-columns: 1fr; }
    .trade-details { grid-template-columns: 1fr; }
  }
</style>
</head>
<body>
  <div class="main-container">
    <div class="header">
      <h1>🚀 Adaptive Trading Signal Bot</h1>
      <p>Smart Strategy Detection Based on Market Conditions</p>
    </div>

    <!-- NEW: Error Display Panel -->
    <div id="error-panel" class="error-panel">
      <div class="error-header">
        <span>⚠️ SYSTEM ERROR</span>
        <button onclick="hideError()" style="margin-left: auto; background: #ff4444; color: white; border: none; padding: 5px 10px; border-radius: 5px; cursor: pointer;">Dismiss</button>
      </div>
      <div id="error-message">An error occurred</div>
      <div class="error-details" id="error-details"></div>
    </div>

    <!-- NEW: Auto-Recovery Status -->
    <div id="recovery-status" class="recovery-status">
      <div style="color: #00ff00; font-weight: bold;">🔄 AUTO-RECOVERY IN PROGRESS</div>
      <div id="recovery-message" style="font-size: 12px; margin-top: 5px;"></div>
    </div>

    <div class="layout">
      <!-- MAIN PANEL -->
      <div class="main-panel">
        <div class="controls-grid">
          <div class="control-group">
            <label>📊 Timeframe</label>
            <select id="timeframe">
              <option value="1m">1 Minute</option>
              <option value="5m">5 Minutes</option>
              <option value="15m" selected>15 Minutes</option>
              <option value="1h">1 Hour</option>
              <option value="4h">4 Hours</option>
            </select>
          </div>

          <div class="control-group">
            <label>⚡ Risk Level</label>
            <select id="risk-level">
              <option value="conservative" selected>Conservative</option>
              <option value="moderate">Moderate</option>
              <option value="aggressive">Aggressive</option>
            </select>
          </div>

          <div class="control-group">
            <label>🎯 TP Multiplier</label>
            <input type="number" id="tp-multiplier" value="1.5" step="0.1" min="1" max="5">
          </div>

          <div class="control-group">
            <label>💰 Symbol/Pair</label>
            <select id="symbol">
              <option value="XRPUSDT" selected>XRP/USDT</option>
              <option value="BTCUSDT">BTC/USDT</option>
              <option value="ETHUSDT">ETH/USDT</option>
              <option value="ADAUSDT">ADA/USDT</option>
              <option value="DOTUSDT">DOT/USDT</option>
              <option value="LINKUSDT">LINK/USDT</option>
              <option value="LTCUSDT">LTC/USDT</option>
              <option value="BCHUSDT">BCH/USDT</option>
              <option value="XLMUSDT">XLM/USDT</option>
              <option value="EOSUSDT">EOS/USDT</option>
            </select>
          </div>
          
          <div class="control-group">
            <label>🎚️ Signal Filter Strength</label>
            <select id="filter-strength">
              <option value="normal">Normal</option>
              <option value="strict" selected>Strict</option>
              <option value="very-strict">Very Strict</option>
            </select>
          </div>
          
          <!-- NEW: Trading Strategy Selection -->
          <div class="control-group">
            <label>🎯 Trading Strategy</label>
            <select id="trading-strategy">
              <option value="auto" selected>🔄 AUTO (Adaptive)</option>
              <option value="enhanced">Enhanced Trend</option>
              <option value="crt">CRT (Candle Range Theory)</option>
              <option value="orb">ORB (Opening Range Breakout)</option>
              <option value="smc">Smart Money Concepts</option>
            </select>
          </div>

          <!-- NEW: Exchange Selection -->
          <div class="control-group">
            <label>🏦 Exchange</label>
            <select id="exchange">
              <option value="bitget" selected>Bitget</option>
              <option value="binance">Binance</option>
            </select>
          </div>

          <!-- NEW: Circuit Breaker Settings -->
          <div class="control-group">
            <label>⚡ Circuit Breaker</label>
            <select id="circuit-breaker">
              <option value="auto" selected>Auto (Recommended)</option>
              <option value="enabled">Enabled</option>
              <option value="disabled">Disabled</option>
            </select>
          </div>
        </div>

        <div class="buttons-container">
          <button id="start-btn" onclick="startBot()">▶ START LIVE SIGNAL</button>
          <button id="stop-btn" onclick="stopBot()">■ STOP BOT</button>
          <button id="backtest-btn" onclick="runBacktest()">📈 RUN BACKTEST</button>
          <button id="unlock-btn" onclick="unlockSignal()">🔓 UNLOCK SIGNAL</button>
          <!-- NEW: Recovery Button -->
          <button id="recover-btn" onclick="attemptRecovery()" style="background: linear-gradient(45deg, #00aaff, #0088cc); color: white; display: none;">🔄 RECOVER BOT</button>
        </div>

        <div class="signal-display">
          <h2 id="signal-type" class="hold">HOLD</h2>
          
          <div class="signal-info">
            <p><strong>Entry:</strong> <span id="entry-price">-</span></p>
            <p><strong>Take Profit:</strong> <span id="tp-price">-</span></p>
            <p><strong>Stop Loss:</strong> <span id="sl-price">-</span></p>
            <p><strong>Risk/Reward:</strong> <span id="risk-reward">-</span></p>
            <p><strong>Volume Confirmation:</strong> <span id="volume-confirmation">-</span></p>
            <p><strong>Market Regime:</strong> <span id="market-regime">-</span></p>
            <p><strong>Trend:</strong> <span id="trend-type">-</span></p>
            <p><strong>Strategy:</strong> <span id="strategy-type">-</span></p>
            <p><strong>Adaptive Score:</strong> <span id="adaptive-score">-</span></p>
          </div>

          <div class="confidence-bar">
            <div class="confidence-fill" id="confidence-fill">0%</div>
          </div>
          <p id="confidence-text" style="font-size: 16px; font-weight: 600;">Confidence: 0%</p>
        </div>
      </div>

      <!-- SIDEBAR -->
      <div class="sidebar">
        <div class="signals-feed">
          <h3>📡 Adaptive Signals Feed</h3>
          <div class="signals-container" id="signals-container">
            <div style="text-align: center; color: #666; padding: 40px 20px;">
              <p>🔄 Waiting for adaptive signals...</p>
              <p style="font-size: 12px; margin-top: 10px;">Start the bot to see smart strategy detection</p>
            </div>
          </div>
        </div>

        <!-- NEW: Active Trade Panel -->
        <div class="active-trade-panel">
          <h4>💼 Active Trade Status</h4>
          <div id="trade-status" class="trade-status inactive">
            No Active Trade
          </div>
          <div id="trade-details" class="trade-details">
            <div><strong>Signal:</strong> <span id="active-trade-signal">-</span></div>
            <div><strong>Entry:</strong> <span id="active-trade-entry">-</span></div>
            <div><strong>TP:</strong> <span id="active-trade-tp">-</span></div>
            <div><strong>SL:</strong> <span id="active-trade-sl">-</span></div>
            <div><strong>Current P/L:</strong> <span id="active-trade-pl">-</span></div>
            <div><strong>Status:</strong> <span id="active-trade-result">-</span></div>
          </div>
        </div>

        <div class="status-panel">
          <h4>📊 Adaptive Bot Status</h4>
          <div class="status-info">
            <span>Status:</span>
            <span id="status" style="color: #ff4444;">STOPPED</span>
          </div>
          <div class="status-info">
            <span>WebSocket:</span>
            <span id="ws-status" style="color: #ff4444;">❌ Disconnected</span>
          </div>
          <div class="status-info">
            <span>Candles Loaded:</span>
            <span id="candle-count">0</span>
          </div>
          <div class="status-info">
            <span>API Status:</span>
            <span id="api-status" style="color: #ff4444;">❌ Disconnected</span>
          </div>
          <div class="status-info">
            <span>Adaptive Signals:</span>
            <span id="signal-count">0</span>
          </div>
          <div class="status-info">
            <span>Current Regime:</span>
            <span id="current-regime" style="color: #cccccc;">N/A</span>
          </div>
          <div class="status-info">
            <span>Trend Direction:</span>
            <span id="trend-direction" style="color: #cccccc;">N/A</span>
          </div>
          <div class="status-info">
            <span>Active Strategy:</span>
            <span id="active-strategy" style="color: #cccccc;">N/A</span>
          </div>
          <!-- NEW: Performance Metrics -->
          <div class="status-info">
            <span>Performance Score:</span>
            <span id="performance-score" style="color: #cccccc;">0%</span>
          </div>
          <div class="status-info">
            <span>Error Count:</span>
            <span id="error-count" style="color: #cccccc;">0</span>
          </div>
          <div class="status-info">
            <span>Circuit Breaker:</span>
            <span id="circuit-status" style="color: #cccccc;">READY</span>
          </div>
        </div>
      </div>
    </div>

    <!-- BOTTOM SECTION -->
    <div class="bottom-section">
      <div class="section-tabs">
        <button class="tab-button active" onclick="switchTab('chart')">📈 Adaptive Chart</button>
        <button class="tab-button" onclick="switchTab('trades')">📋 Adaptive Trade Log</button>
        <button class="tab-button" onclick="switchTab('analysis')">🔍 Market Analysis</button>
        <button class="tab-button" onclick="switchTab('strategy')">🎯 Strategy Analysis</button>
        <button class="tab-button" onclick="switchTab('performance')">⚡ Performance</button>
      </div>

      <div class="tab-content">
        <div id="chart-tab" class="tab-panel">
          <div id="chart"></div>
        </div>

        <div id="trades-tab" class="tab-panel" style="display: none;">
          <h2>📑 Adaptive Trade Log</h2>
          <table id="trade-log">
            <thead>
              <tr>
                <th>Time</th><th>Symbol</th><th>Signal</th><th>Entry</th><th>TP</th><th>SL</th><th>RR</th><th>Confidence</th><th>Regime</th><th>Trend</th><th>Volume Conf</th><th>Patterns</th><th>Strategy</th><th>Adaptive Score</th><th>Result</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>

        <div id="analysis-tab" class="tab-panel" style="display: none;">
          <h2>🔍 Advanced Market Analysis</h2>
          <div id="market-analysis">
            <div class="analysis-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-top: 20px;">
              <div class="analysis-card" style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px; border: 1px solid #444;">
                <h4>Volume Analysis</h4>
                <p id="volume-analysis">Loading...</p>
              </div>
              <div class="analysis-card" style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px; border: 1px solid #444;">
                <h4>Trend Strength</h4>
                <p id="trend-strength">Loading...</p>
              </div>
              <div class="analysis-card" style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px; border: 1px solid #444;">
                <h4>Support/Resistance</h4>
                <p id="support-resistance">Loading...</p>
              </div>
              <div class="analysis-card" style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px; border: 1px solid #444;">
                <h4>Pattern Detection</h4>
                <p id="pattern-detection">Loading...</p>
              </div>
            </div>
          </div>
        </div>

        <!-- NEW: Strategy Analysis Tab -->
        <div id="strategy-tab" class="tab-panel" style="display: none;">
          <h2>🎯 Adaptive Strategy Analysis</h2>
          <div id="strategy-analysis">
            <div class="analysis-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-top: 20px;">
              <div class="analysis-card" style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px; border: 1px solid #444;">
                <h4>Strategy Scores</h4>
                <div id="strategy-scores">Calculating...</div>
              </div>
              <div class="analysis-card" style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px; border: 1px solid #444;">
                <h4>Market Conditions</h4>
                <div id="market-conditions">Analyzing...</div>
              </div>
              <div class="analysis-card" style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px; border: 1px solid #444;">
                <h4>Strategy Triggers</h4>
                <div id="strategy-triggers">Waiting for data...</div>
              </div>
              <div class="analysis-card" style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px; border: 1px solid #444;">
                <h4>Adaptive Logic</h4>
                <div id="adaptive-logic">Initializing...</div>
              </div>
            </div>
          </div>
        </div>

        <!-- NEW: Performance Tab -->
        <div id="performance-tab" class="tab-panel" style="display: none;">
          <h2>⚡ Performance & Health Metrics</h2>
          <div id="performance-metrics">
            <div class="analysis-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-top: 20px;">
              <div class="analysis-card" style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px; border: 1px solid #444;">
                <h4>System Health</h4>
                <div id="system-health">Checking...</div>
              </div>
              <div class="analysis-card" style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px; border: 1px solid #444;">
                <h4>Performance Metrics</h4>
                <div id="performance-stats">Calculating...</div>
              </div>
              <div class="analysis-card" style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px; border: 1px solid #444;">
                <h4>Error Log</h4>
                <div id="error-log" style="max-height: 150px; overflow-y: auto; font-size: 12px;"></div>
              </div>
              <div class="analysis-card" style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px; border: 1px solid #444;">
                <h4>Circuit Breaker Status</h4>
                <div id="circuit-breaker-status">Initializing...</div>
              </div>
            </div>
          </div>
        </div>

        <div id="backtest-results"></div>
      </div>
    </div>
  </div>

  <audio id="alert-sound" src="https://actions.google.com/sounds/v1/alarms/alarm_clock.ogg" preload="auto"></audio>
<script>
/* -------------------------
   Enhanced Config / Globals
   ------------------------- */
let isRunning = false;
let lastSignal = null;
let candleBuffer = [];
const BUFFER_SIZE = 600;
let ws = null;
let signalCount = 0;
let lastSignalTime = 0;
const SIGNAL_COOLDOWN = 30000;

// NEW: Enhanced error handling and recovery
let errorCount = 0;
let consecutiveErrors = 0;
const MAX_CONSECUTIVE_ERRORS = 5;
let circuitBreakerTripped = false;
let recoveryAttempts = 0;
const MAX_RECOVERY_ATTEMPTS = 3;
let performanceMetrics = {
  startTime: null,
  signalsGenerated: 0,
  errorsEncountered: 0,
  recoveryAttempts: 0,
  wsReconnects: 0,
  avgProcessingTime: 0,
  lastHealthCheck: null
};

// NEW: Active trade tracking
let activeTrade = null;
let tradeHistory = [];

// NEW: Strategy tracking
let currentStrategy = "auto";
let strategyScores = {};
let adaptiveScores = [];
let currentORBLevels = null;

// Trading sessions in UTC
const TRADING_SESSIONS = {
  ASIAN: { start: 0, end: 9 },
  LONDON: { start: 7, end: 16 },
  NEWYORK: { start: 13, end: 22 }
};

// 🔧 UPDATED: Enhanced Configuration with XRP Optimizations
const enhancedConfig = {
    // 🔧 PRECISION: Optimized regime settings based on XRP backtest
    regimeSettings: {
        TRENDING: {
            minConfidence: 62, // Further reduced for XRP
            rrRatio: 2.2,
            positionSizeMultiplier: 1.1,
            filterStrength: 'high'
        },
        RANGING: {
            minConfidence: 68, // Slightly increased for ranging
            rrRatio: 1.6,
            positionSizeMultiplier: 0.6,
            filterStrength: 'very_high'
        },
        VOLATILE: {
            minConfidence: 72, // Reduced for XRP volatility
            rrRatio: 2.0,
            positionSizeMultiplier: 0.4,
            filterStrength: 'extreme'
        },
        NEUTRAL: {
            minConfidence: 65, // Reduced
            rrRatio: 1.9,
            positionSizeMultiplier: 0.8,
            filterStrength: 'high'
        }
    },
    
    // 🔧 PRECISION: Optimized weights for XRP based on backtest
    adaptiveWeights: {
        TRENDING: { enhanced: 0.85, crt: 0.4, orb: 0.3, smc: 0.7 },
        RANGING: { enhanced: 0.7, crt: 0.8, orb: 0.9, smc: 0.5 },
        VOLATILE: { enhanced: 0.8, crt: 0.5, orb: 0.2, smc: 0.9 },
        NEUTRAL: { enhanced: 0.75, crt: 0.8, orb: 0.7, smc: 0.6 }
    },
    
    // 🔧 PRECISION: Strategy conditions optimized for XRP
    strategyConditions: {
        enhanced: {
            minTrendStrength: 25, // Reduced for XRP
            maxVolatility: 0.035, // Increased for XRP
            volumeMultiplier: 1.1
        },
        crt: {
            minRangeSize: 0.004, // Adjusted for XRP
            maxVolatility: 0.025,
            volumeMultiplier: 0.9
        },
        orb: {
            sessionStartWindow: 15,
            minRangeSize: 0.0025, // Reduced for XRP
            volumeMultiplier: 1.3
        },
        smc: {
            minOrderBlocks: 1,
            minLiquiditySweeps: 1,
            volumeMultiplier: 1.2
        }
    },
    
    // 🔧 NEW: XRP-specific optimizations
    xrpOptimizations: {
        trendSensitivity: 0.8, // XRP tends to have weaker trends
        volatilityMultiplier: 1.2, // XRP is more volatile
        sessionStrength: 1.1, // XRP performs better in specific sessions
        minAtrForEntry: 0.008 // Minimum ATR for valid signals
    },
    
    // 🔧 PRECISION: Enhanced stop loss for XRP
    stopLossOptimization: {
        atrMultiplier: 1.25, // Tighter for XRP
        maxRiskPercent: 0.012, // 1.2% max risk for XRP
        trailingStart: 0.01, // Start trailing at 1% profit
        trailingStep: 0.005, // Trail by 0.5%
        volatilityAdjustment: true // Adjust SL based on current volatility
    }
};

/* -------------------------
   🔧 NEW: BITGET SUPPORT FUNCTIONS
   ------------------------- */
function getExchangeEndpoints(exchange, symbol, interval) {
    const timeframeMapping = {
        '1m': '1min',
        '5m': '5min',
        '15m': '15min',
        '1h': '1h',
        '4h': '4h'
    };

    if (exchange === 'bitget') {
        return {
            historical: `https://api.bitget.com/api/spot/v1/market/candles?symbol=${symbol}&period=${timeframeMapping[interval]}&limit=${BUFFER_SIZE}`,
            websocket: `wss://ws.bitget.com/spot/v1/stream`
        };
    } else { // binance
        return {
            historical: `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=${BUFFER_SIZE}`,
            websocket: `wss://stream.binance.com:9443/ws/${symbol.toLowerCase()}@kline_${interval}`
        };
    }
}

function parseCandleData(exchange, data) {
    if (exchange === 'bitget') {
        // Bitget format: [timestamp, open, high, low, close, volume, quote_volume]
        return {
            time: parseInt(data[0]),
            open: parseFloat(data[1]),
            high: parseFloat(data[2]),
            low: parseFloat(data[3]),
            close: parseFloat(data[4]),
            volume: parseFloat(data[5])
        };
    } else { // binance
        // Binance format: [0: open time, 1: open, 2: high, 3: low, 4: close, 5: volume]
        return {
            time: data[0],
            open: parseFloat(data[1]),
            high: parseFloat(data[2]),
            low: parseFloat(data[3]),
            close: parseFloat(data[4]),
            volume: parseFloat(data[5])
        };
    }
}

function parseWebSocketData(exchange, message) {
    try {
        const data = JSON.parse(message.data);
        
        if (exchange === 'bitget') {
            if (data.data && data.data.length > 0) {
                const candleData = data.data[0];
                return {
                    time: parseInt(candleData[0]),
                    open: parseFloat(candleData[1]),
                    high: parseFloat(candleData[2]),
                    low: parseFloat(candleData[3]),
                    close: parseFloat(candleData[4]),
                    volume: parseFloat(candleData[5]),
                    isClosed: true // Bitget sends complete candles
                };
            }
        } else { // binance
            if (data.k) {
                const k = data.k;
                return {
                    time: k.t,
                    open: parseFloat(k.o),
                    high: parseFloat(k.h),
                    low: parseFloat(k.l),
                    close: parseFloat(k.c),
                    volume: parseFloat(k.v),
                    isClosed: k.x
                };
            }
        }
    } catch (error) {
        logError(error, 'WebSocket Data Parsing');
    }
    return null;
}

function getWebSocketSubscribeMessage(exchange, symbol, interval) {
    if (exchange === 'bitget') {
        const channelMap = {
            '1m': 'candle1m',
            '5m': 'candle5m',
            '15m': 'candle15m',
            '1h': 'candle1h',
            '4h': 'candle4h'
        };
        return JSON.stringify({
            op: "subscribe",
            args: [{
                instType: "SPOT",
                channel: channelMap[interval],
                instId: symbol
            }]
        });
    }
    return null; // Binance doesn't need subscribe message
}

/* -------------------------
   🔧 NEW: XRP-SPECIFIC OPTIMIZATIONS
   ------------------------- */

function optimizeForXRP(marketConditions, symbol) {
    if (!symbol.includes('XRP')) return marketConditions;
    
    // XRP-specific adjustments
    const optimizedConditions = {...marketConditions};
    
    // XRP has different volatility characteristics
    optimizedConditions.volatility *= enhancedConfig.xrpOptimizations.volatilityMultiplier;
    
    // Adjust trend strength for XRP
    optimizedConditions.trendStrength *= enhancedConfig.xrpOptimizations.trendSensitivity;
    
    return optimizedConditions;
}

// 🔧 NEW: Improved confidence calculation for XRP
function calculateXRPConfidence(baseConfidence, marketConditions, strategy) {
    let confidence = baseConfidence;
    
    // XRP-specific confidence adjustments
    if (marketConditions.volatility > 0.025) {
        confidence *= 0.9; // Reduce confidence in high volatility
    }
    
    // Strategy-specific adjustments for XRP
    switch(strategy) {
        case 'crt':
            // CRT works well in XRP ranging markets
            if (marketConditions.regime === 'RANGING') {
                confidence *= 1.1;
            }
            break;
        case 'enhanced':
            // Enhanced needs stronger trends in XRP
            if (marketConditions.trendStrength > 40) {
                confidence *= 1.15;
            }
            break;
    }
    
    return Math.min(95, Math.max(40, confidence));
}

/* -------------------------
   🔧 PRECISION: ENHANCED LOSS PREVENTION SYSTEM
   ------------------------- */

let lossPrevention = {
    consecutiveLosses: 0,
    lastWinTime: null,
    currentDrawdown: 0,
    maxDrawdown: 0,
    tradeHistory: []
};

function updateLossPrevention(result, pnl) {
    if (pnl < 0) {
        lossPrevention.consecutiveLosses++;
        lossPrevention.currentDrawdown += Math.abs(pnl);
    } else {
        lossPrevention.consecutiveLosses = 0;
        lossPrevention.currentDrawdown = 0;
        lossPrevention.lastWinTime = Date.now();
    }
    
    lossPrevention.maxDrawdown = Math.max(lossPrevention.maxDrawdown, lossPrevention.currentDrawdown);
    lossPrevention.tradeHistory.push({ result, pnl, time: Date.now() });
    
    // Keep only last 50 trades
    if (lossPrevention.tradeHistory.length > 50) {
        lossPrevention.tradeHistory.shift();
    }
}

function shouldReduceRisk() {
    const recentTrades = lossPrevention.tradeHistory.slice(-20);
    const losses = recentTrades.filter(t => t.pnl < 0).length;
    const lossRate = losses / recentTrades.length;
    
    return lossPrevention.consecutiveLosses >= 3 || 
           lossRate > 0.6 ||
           lossPrevention.currentDrawdown > 0.05; // 5% drawdown
}

function getRiskMultiplier() {
    if (shouldReduceRisk()) {
        const reduction = 1 - (lossPrevention.consecutiveLosses * 0.2);
        return Math.max(0.3, reduction);
    }
    return 1.0;
}

/* -------------------------
   🔧 PRECISION: ENHANCED ENTRY TIMING
   ------------------------- */

function getOptimalEntryTiming(data) {
    const volatility = calculateVolatility(data);
    const volume = analyzeVolumeProfile(data);
    const atr = ATR(data);
    const currentATR = atr[atr.length-1] || 0;
    
    let timingScore = 0;
    
    // Higher volume = better timing
    if (volume > 1.5) timingScore += 2;
    else if (volume > 1.2) timingScore += 1;
    
    // Moderate volatility = better timing
    if (volatility > 0.008 && volatility < 0.02) timingScore += 2;
    else if (volatility < 0.005) timingScore -= 1; // Too low volatility
    
    // ATR check for minimum movement
    if (currentATR < enhancedConfig.xrpOptimizations.minAtrForEntry) {
        timingScore -= 2;
    }
    
    return timingScore;
}

/* -------------------------
   🔧 UPDATED: OPTIMIZED STOP LOSS WITH TRAILING
   ------------------------- */
function optimizedStopLoss(data, signalType, confidence, entryPrice) {
    const lastClose = data[data.length-1].close;
    const atr = ATR(data);
    const currentATR = atr[atr.length-1] || lastClose * 0.008;
    
    let atrMultiplier = enhancedConfig.stopLossOptimization.atrMultiplier;
    
    // Dynamic multiplier based on confidence and volatility
    if (confidence > 75) {
        atrMultiplier = 1.1;
    } else if (confidence < 65) {
        atrMultiplier = 1.5;
    }
    
    const regimeAnalysis = enhancedMarketRegimeDetection(data);
    if (regimeAnalysis.regime === 'RANGING') {
        atrMultiplier *= 0.7;
    }

    let sl;
    if (signalType === 'BUY') {
        sl = lastClose - (currentATR * atrMultiplier);
        sl = Math.max(sl, lastClose * (1 - enhancedConfig.stopLossOptimization.maxRiskPercent));
    } else {
        sl = lastClose + (currentATR * atrMultiplier);
        sl = Math.min(sl, lastClose * (1 + enhancedConfig.stopLossOptimization.maxRiskPercent));
    }
    
    return sl;
}

/* -------------------------
   🔧 UPDATED: ENHANCED SIGNAL GENERATION WITH XRP OPTIMIZATIONS
   ------------------------- */

function generateEnhancedSignal(data, riskLevel, tpMultiplier){
  if(!data || data.length < 50) return { 
    signal:"HOLD", 
    entry: data.length > 0 ? data[data.length-1].close : 0, 
    tp: 0, sl: 0, confidence:0, rr: 0, 
    confirmations: [], marketRegime: "NEUTRAL", volumeConfirmation: "N/A", patterns: [],
    trend: "NEUTRAL", trendStrength: 0, retracement: { isRetracement: false, level: 0, completion: 0 },
    fvGaps: [], strategy: "Enhanced", adaptiveScore: 0,
    trendConfirmed: false, counterTrend: false, rejectionReason: "Insufficient data"
  };

  const symbol = document.getElementById("symbol").value.toUpperCase();
  const last = data[data.length-1];
  const lastClose = last.close;

  // 🔧 NEW: XRP-specific market condition optimization
  let marketConditions = analyzeMarketConditions(data);
  marketConditions = optimizeForXRP(marketConditions, symbol);
  
  // Get selected strategy
  const selectedStrategy = document.getElementById("trading-strategy").value;
  
  // Trend confirmation
  const trendConfirmation = confirmTrendWithMultipleTimeframes(data, document.getElementById("timeframe").value);
  
  // Adaptive strategy selection
  let finalStrategy = selectedStrategy;
  let adaptiveResult = null;
  
  if (selectedStrategy === "auto") {
    adaptiveResult = adaptiveStrategySelection(data);
    finalStrategy = adaptiveResult.strategy;
    currentStrategy = finalStrategy;
  } else {
    currentStrategy = selectedStrategy;
  }

  // Generate signal based on selected strategy
  let strategySignal = { signal: "HOLD", confidence: 0, strategy: finalStrategy };
  
  switch(finalStrategy) {
    case "crt":
      const crtSetup = detectCRTSetup(data);
      if (crtSetup.valid) {
        // 🔧 NEW: XRP-specific CRT validation
        const crtConfidence = calculateXRPConfidence(crtSetup.confidence, marketConditions, 'crt');
        strategySignal = {
          signal: crtSetup.direction,
          confidence: crtConfidence,
          strategy: "CRT",
          crtLevels: { CRH: crtSetup.CRH, CRL: crtSetup.CRL }
        };
      }
      break;
      
    case "orb":
      if (isSessionStart() && !currentORBLevels) {
        currentORBLevels = setupORBLevels(data);
      }
      strategySignal = generateORBSignal(data, currentORBLevels);
      // 🔧 NEW: XRP confidence adjustment
      if (strategySignal.signal !== "HOLD") {
        strategySignal.confidence = calculateXRPConfidence(strategySignal.confidence, marketConditions, 'orb');
      }
      break;
      
    case "smc":
      const orderBlocks = detectOrderBlocks(data);
      const liquiditySweeps = detectLiquiditySweeps(data);
      
      if (orderBlocks.length > 0 && liquiditySweeps.length > 0) {
        const recentOB = orderBlocks[orderBlocks.length-1];
        const recentSweep = liquiditySweeps[liquiditySweeps.length-1];
        
        if (recentSweep.timestamp > recentOB.timestamp) {
          const direction = recentSweep.type === 'UP' ? 'SELL' : 'BUY';
          const smcConfidence = calculateXRPConfidence(75, marketConditions, 'smc');
          strategySignal = {
            signal: direction,
            confidence: smcConfidence,
            strategy: "SMC",
            orderBlock: recentOB,
            liquiditySweep: recentSweep
          };
        }
      }
      break;
      
    default:
      const enhancedSignal = generateEnhancedTrendSignal(data, riskLevel, tpMultiplier);
      strategySignal = {
        signal: enhancedSignal.signal,
        confidence: calculateXRPConfidence(enhancedSignal.confidence, marketConditions, 'enhanced'),
        strategy: "Enhanced"
      };
      break;
  }

  // 🔧 UPDATED: Enhanced validation with loss prevention
  let finalSignal = "HOLD";
  let finalConfidence = 0;
  let rejectionReason = "No valid setup";
  let trendConfirmed = false;
  let counterTrend = false;

  // 🔧 NEW: Entry timing check
  const timingScore = getOptimalEntryTiming(data);
  const poorTiming = timingScore < 0;

  if (strategySignal.signal !== "HOLD" && strategySignal.confidence > 60 && !poorTiming) {
    
    // Check if this is a counter-trend trade
    const counterTrendCheck = isCounterTrendTrade(strategySignal.signal, trendConfirmation.details.trend);
    
    // Flexible trend confirmation for high-quality strategies
    const isHighQualityStrategy = strategySignal.strategy === "crt" || strategySignal.strategy === "smc";
    
    // 🔧 FIX: Lower threshold for high-quality strategies
    if (!trendConfirmation.confirmed) {
        if (isHighQualityStrategy && trendConfirmation.strength > 20) {
            trendConfirmed = true;
            finalConfidence = strategySignal.confidence * 0.85;
            rejectionReason = `High-quality ${strategySignal.strategy} setup (trend strength: ${trendConfirmation.strength.toFixed(1)})`;
        } else {
            rejectionReason = `Trend not confirmed (${trendConfirmation.direction}, strength: ${trendConfirmation.strength.toFixed(1)})`;
        }
    } else if (counterTrendCheck.isCounterTrend) {
        rejectionReason = counterTrendCheck.reason;
        counterTrend = true;
        
        // Allow counter-trend trades with better conditions
        const oversoldCondition = trendConfirmation.details.rsi < 35 && strategySignal.signal === "BUY";
        const overboughtCondition = trendConfirmation.details.rsi > 65 && strategySignal.signal === "SELL";
        
        if (strategySignal.confidence > 80 && (oversoldCondition || overboughtCondition)) {
            trendConfirmed = true;
            finalConfidence = strategySignal.confidence * 0.75;
            rejectionReason = `High-confidence counter-trade allowed (RSI: ${trendConfirmation.details.rsi?.toFixed(1) || 'N/A'})`;
        }
    } else {
        // Trading with trend - full confidence
        trendConfirmed = true;
        finalConfidence = strategySignal.confidence;
        rejectionReason = "Trend confirmed";
    }
    
    // 🔧 NEW: Loss prevention check
    const riskMultiplier = getRiskMultiplier();
    if (riskMultiplier < 0.5 && finalConfidence < 75) {
        trendConfirmed = false;
        rejectionReason = `Risk reduction active (consecutive losses: ${lossPrevention.consecutiveLosses})`;
    }
    
    if (trendConfirmed) {
        const marketConditions = analyzeMarketConditions(data);
        const signalAccepted = shouldAcceptSignal(strategySignal.signal, marketConditions, finalConfidence);
        
        if (!signalAccepted) {
            trendConfirmed = false;
            finalSignal = "HOLD";
            rejectionReason = "Signal filtered by market conditions";
        } else {
            finalSignal = strategySignal.signal;
        }
    }
  }

  // Calculate entry, TP, SL only if signal is confirmed
  let entry = lastClose;
  let tp = lastClose;
  let sl = lastClose;
  let rr = 0;

  if (finalSignal !== "HOLD" && finalConfidence > 65) {
    entry = lastClose;
    sl = smartStopLoss(data, finalSignal, finalConfidence);
    const risk = Math.max(Math.abs(entry - sl), entry * 0.002);
    
    // 🔧 NEW: Dynamic TP based on confidence and risk multiplier
    const dynamicTPMultiplier = tpMultiplier * (finalConfidence / 100) * getRiskMultiplier();
    tp = finalSignal === "BUY" ? entry + (risk * dynamicTPMultiplier) : entry - (risk * dynamicTPMultiplier);
    rr = tpMultiplier;
  }

  return { 
    signal: finalSignal,
    entry: entry,
    tp: tp,
    sl: sl,
    confidence: finalConfidence,
    rr: rr,
    confirmations: trendConfirmed ? [
        `${strategySignal.strategy} Setup`, 
        `Trend: ${trendConfirmation.direction}`,
        `Timing: ${timingScore >= 2 ? 'Good' : timingScore >= 0 ? 'OK' : 'Poor'}`
    ] : [rejectionReason],
    marketRegime: trendConfirmation.details.trend.trend,
    volumeConfirmation: trendConfirmation.details.volume.strength,
    patterns: [],
    trend: trendConfirmation.details.trend.trend,
    trendStrength: trendConfirmation.details.trend.strength,
    retracement: { isRetracement: false, level: 0, completion: 0 },
    fvGaps: 0,
    strategy: strategySignal.strategy,
    adaptiveScore: adaptiveResult ? adaptiveResult.score : 0,
    trendConfirmed: trendConfirmed,
    counterTrend: counterTrend,
    rejectionReason: rejectionReason,
    trendDetails: {
      direction: trendConfirmation.direction,
      strength: trendConfirmation.strength,
      volumeConfirmed: trendConfirmation.volumeConfirmed,
      rsiConfirmed: trendConfirmation.rsiConfirmed
    },
    positionSize: calculatePositionSize(finalConfidence, trendConfirmation.details.trend.trend, 1000),
    // 🔧 NEW: Additional metrics
    timingScore: timingScore,
    riskMultiplier: getRiskMultiplier(),
    lossPrevention: {
        consecutiveLosses: lossPrevention.consecutiveLosses,
        currentDrawdown: lossPrevention.currentDrawdown
    }
  };
}

/* -------------------------
   CORE INDICATOR FUNCTIONS
   ------------------------- */
function SMA(data, period, field="close"){
  return data.map((_,i)=> i < period ? null : data.slice(i-period, i).reduce((a,b)=>a + b[field], 0) / period );
}

function EMA(data, period){
  const res = [];
  const k = 2/(period+1);
  if(data.length === 0) return res;
  let sum = 0;
  for(let i=0;i<data.length;i++){
    if(i < period){
      sum += data[i].close;
      res.push(null);
      if(i === period-1) {
        const sma = sum/period;
        res[i] = sma;
      }
    } else {
      res[i] = data[i].close * k + res[i-1] * (1-k);
    }
  }
  return res;
}

function advancedRSI(data, period=14) {
    let gains = 0, losses = 0;
    let rsiValues = [];
    
    for (let i = 1; i < data.length; i++) {
        const change = data[i].close - data[i-1].close;
        gains += Math.max(change, 0);
        losses += Math.abs(Math.min(change, 0));
        
        if (i >= period) {
            const avgGain = gains / period;
            const avgLoss = losses / period;
            const rs = avgGain / (avgLoss || 0.001);
            const rsi = 100 - (100 / (1 + rs));
            rsiValues.push(rsi);
            
            const oldChange = data[i-period+1].close - data[i-period].close;
            gains -= Math.max(oldChange, 0);
            losses -= Math.abs(Math.min(oldChange, 0));
        } else {
            rsiValues.push(null);
        }
    }
    return rsiValues;
}

function ATR(data, period=14){
  let tr = [];
  for (let i=1;i<data.length;i++){
    const h = data[i].high, l = data[i].low, pc = data[i-1].close;
    tr.push(Math.max(h-l, Math.abs(h-pc), Math.abs(l-pc)));
  }
  return tr.map((_,i)=> i < period ? null : tr.slice(i-period, i).reduce((a,b)=>a+b,0) / period );
}

function BollingerBands(data, period=20, stdMult=2){
  let sma = SMA(data, period);
  return data.map((c,i)=>{
    if(i < period-1) return { upper: null, lower: null };
    let slice = data.slice(i-period+1, i+1).map(x=>x.close);
    let mean = sma[i];
    let std = Math.sqrt(slice.reduce((a,b)=>a + Math.pow(b-mean,2),0) / period);
    return { upper: mean + stdMult * std, lower: mean - stdMult * std };
  });
}

function fibonacciLevels(data){
  let recent = data.slice(-50);
  if(recent.length === 0) return {};
  let high = Math.max(...recent.map(c=>c.high));
  let low = Math.min(...recent.map(c=>c.low));
  return {
    "0": high,
    "0.236": high - (high-low) * 0.236,
    "0.382": high - (high-low) * 0.382,
    "0.5": high - (high-low) * 0.5,
    "0.618": high - (high-low) * 0.618,
    "0.786": high - (high-low) * 0.786,
    "1": low
  };
}

/* -------------------------
   ENHANCED TREND DETECTION FUNCTIONS
   ------------------------- */
function detectTrendType(data) {
    if (data.length < 50) return { trend: "NEUTRAL", strength: 0, direction: "SIDEWAYS" };
    
    // Calculate multiple moving averages
    const sma20 = SMA(data, 20);
    const sma50 = SMA(data, 50);
    const sma100 = SMA(data, 100);
    const ema20 = EMA(data, 20);
    const ema50 = EMA(data, 50);
    
    const currentPrice = data[data.length-1].close;
    const price20 = sma20[sma20.length-1];
    const price50 = sma50[sma50.length-1];
    const price100 = sma100[sma100.length-1];
    const ema20Current = ema20[ema20.length-1];
    const ema50Current = ema50[ema50.length-1];
    
    if (!price20 || !price50 || !price100 || !ema20Current || !ema50Current) {
        return { trend: "NEUTRAL", strength: 0, direction: "SIDEWAYS" };
    }
    
    // Check alignment of moving averages
    const maAlignment = (currentPrice > price20 && price20 > price50 && price50 > price100) ? 1 : 
                       (currentPrice < price20 && price20 < price50 && price50 < price100) ? -1 : 0;
    
    // Calculate trend strength based on slope of MAs
    const slope20 = price20 - sma20[sma20.length-5] || 0;
    const slope50 = price50 - sma50[sma50.length-5] || 0;
    const slope100 = price100 - sma100[sma100.length-5] || 0;
    
    const avgSlope = (slope20 + slope50 + slope100) / 3;
    const normalizedSlope = avgSlope / currentPrice;
    
    // Determine trend type
    let trend, direction, strength;
    
    if (maAlignment === 1 && normalizedSlope > 0.001) {
        trend = "UPTREND";
        direction = "UP";
        strength = Math.min(100, Math.abs(normalizedSlope) * 10000);
    } else if (maAlignment === -1 && normalizedSlope < -0.001) {
        trend = "DOWNTREND";
        direction = "DOWN";
        strength = Math.min(100, Math.abs(normalizedSlope) * 10000);
    } else {
        // Check for ranging market
        const recentHigh = Math.max(...data.slice(-20).map(c => c.high));
        const recentLow = Math.min(...data.slice(-20).map(c => c.low));
        const range = recentHigh - recentLow;
        const rangePercent = range / currentPrice;
        
        if (rangePercent < 0.02) { // Less than 2% range indicates consolidation
            trend = "RANGING";
            direction = "SIDEWAYS";
            strength = Math.min(100, (0.02 - rangePercent) * 5000);
        } else {
            trend = "NEUTRAL";
            direction = "SIDEWAYS";
            strength = 0;
        }
    }
    
    return { trend, strength, direction };
}

function detectRetracement(data, trend) {
    if (data.length < 30 || trend.direction === "SIDEWAYS") return { isRetracement: false, level: 0, completion: 0 };
    
    // Find recent swing high/low based on trend
    let swingPoint, currentPrice;
    const lookback = 15;
    
    if (trend.direction === "UP") {
        // For uptrend, we're looking for pullbacks (retracements down)
        swingPoint = Math.max(...data.slice(-lookback).map(c => c.high));
        currentPrice = data[data.length-1].close;
        
        // Calculate retracement level (0-1, where 1 is full retracement)
        const recentLow = Math.min(...data.slice(-lookback).map(c => c.low));
        const move = swingPoint - recentLow;
        const retrace = swingPoint - currentPrice;
        
        if (move > 0) {
            const retracementLevel = retrace / move;
            return { 
                isRetracement: retracementLevel > 0.1, 
                level: retracementLevel,
                completion: 1 - retracementLevel // How much of the retracement is complete
            };
        }
    } else if (trend.direction === "DOWN") {
        // For downtrend, we're looking for rallies (retracements up)
        swingPoint = Math.min(...data.slice(-lookback).map(c => c.low));
        currentPrice = data[data.length-1].close;
        
        // Calculate retracement level
        const recentHigh = Math.max(...data.slice(-lookback).map(c => c.high));
        const move = recentHigh - swingPoint;
        const retrace = currentPrice - swingPoint;
        
        if (move > 0) {
            const retracementLevel = retrace / move;
            return { 
                isRetracement: retracementLevel > 0.1, 
                level: retracementLevel,
                completion: 1 - retracementLevel
            };
        }
    }
    
    return { isRetracement: false, level: 0, completion: 0 };
}

function detectFairValueGaps(data) {
    const gaps = [];
    if (data.length < 3) return gaps;
    
    for (let i = 2; i < data.length; i++) {
        const current = data[i];
        const prev = data[i-1];
        const prevPrev = data[i-2];
        
        // Bullish FVG: current low > previous high AND previous low > previous previous high
        if (current.low > prev.high && prev.low > prevPrev.high) {
            gaps.push({
                type: "FVG",
                direction: "BULLISH",
                top: Math.min(prev.low, current.low),
                bottom: Math.max(prevPrev.high, prev.high),
                index: i
            });
        }
        
        // Bearish FVG (Inverted FVG): current high < previous low AND previous high < previous previous low
        if (current.high < prev.low && prev.high < prevPrev.low) {
            gaps.push({
                type: "FVG",
                direction: "BEARISH",
                top: Math.min(prevPrev.low, prev.low),
                bottom: Math.max(prev.high, current.high),
                index: i
            });
        }
    }
    
    return gaps.slice(-5); // Return only the most recent 5 gaps
}

function isPriceInFVG(price, fvg) {
    return price >= fvg.bottom && price <= fvg.top;
}

/* -------------------------
   Enhanced Analysis Functions
   ------------------------- */
function volumeConfirmation(data) {
    if (data.length < 20) return { score: 0, strength: 'N/A', ratio: 1 };
    
    const recentVolume = data.slice(-5).map(c => c.volume);
    const avgVolume = data.slice(-20).map(c => c.volume).reduce((a,b)=>a+b)/20;
    const volumeRatio = recentVolume[recentVolume.length-1] / avgVolume;
    
    let score = 0;
    let strength = 'NEUTRAL';
    
    if (volumeRatio > 1.8) {
        score = 2;
        strength = 'STRONG';
    } else if (volumeRatio > 1.3) {
        score = 1;
        strength = 'MODERATE';
    } else if (volumeRatio < 0.7) {
        score = -1;
        strength = 'WEAK';
    }
    
    return { score, strength, ratio: volumeRatio };
}

function calculateVolatility(data, period=20) {
    const returns = [];
    for (let i = 1; i < data.length; i++) {
        returns.push((data[i].close - data[i-1].close) / data[i-1].close);
    }
    const recentReturns = returns.slice(-period);
    const mean = recentReturns.reduce((a, b) => a + b, 0) / period;
    const stdDev = Math.sqrt(recentReturns.reduce((sum, ret) => 
        sum + Math.pow(ret - mean, 2), 0) / period);
    return stdDev;
}

function analyzeVolumeProfile(data) {
    if (data.length < 20) return 1;
    const recentVolume = data.slice(-20).map(c => c.volume);
    const avgVolume = recentVolume.reduce((a, b) => a + b) / 20;
    const currentVolume = data[data.length-1].volume;
    return currentVolume / avgVolume;
}

function calculateTrendStrength(data) {
    if (data.length < 50) return 0;
    const closes = data.map(c => c.close);
    const sma20 = SMA(data, 20);
    const sma50 = SMA(data, 50);
    
    if (!sma20[sma20.length-1] || !sma50[sma50.length-1]) return 0;
    
    const priceVsSMA20 = (closes[closes.length-1] - sma20[sma20.length-1]) / sma20[sma20.length-1];
    const sma20VsSMA50 = (sma20[sma20.length-1] - sma50[sma50.length-1]) / sma50[sma50.length-1];
    
    return Math.abs(priceVsSMA20 + sma20VsSMA50);
}

function findSupportResistance(data, lookback=50) {
    const levels = { support: [], resistance: [] };
    if (data.length < lookback * 2) return levels;
    
    for (let i = lookback; i < data.length - lookback; i++) {
        const window = data.slice(i - lookback, i + lookback);
        const currentHigh = data[i].high;
        const currentLow = data[i].low;
        
        if (currentHigh === Math.max(...window.map(c => c.high))) {
            levels.resistance.push(currentHigh);
        }
        if (currentLow === Math.min(...window.map(c => c.low))) {
            levels.support.push(currentLow);
        }
    }
    return levels;
}

function enhancedMarketRegimeDetection(data) {
    const volatility = calculateVolatility(data);
    const volumeProfile = analyzeVolumeProfile(data);
    const trendStrength = calculateTrendStrength(data);
    
    if (trendStrength > 0.02 && volumeProfile > 1.2) {
        return { regime: 'TRENDING', confidence: Math.min(100, trendStrength * 1000) };
    } else if (volatility < 0.005 && volumeProfile < 1.0) {
        return { regime: 'RANGING', confidence: Math.min(100, (0.01 - volatility) * 10000) };
    } else if (volatility > 0.03) {
        return { regime: 'VOLATILE', confidence: Math.min(100, volatility * 1000) };
    }
    return { regime: 'NEUTRAL', confidence: 50 };
}

function enhancedPatternDetection(data) {
    const patterns = [];
    if (data.length < 10) return patterns;
    
    // Simple pattern detection (you can enhance this further)
    const last = data[data.length-1];
    const prev = data[data.length-2];
    
    // Bullish engulfing
    if (prev.open > prev.close && last.open < last.close && last.close > prev.open) {
        patterns.push("BULL_ENGULFING");
    }
    // Bearish engulfing
    if (prev.open < prev.close && last.open > last.close && last.close < prev.open) {
        patterns.push("BEAR_ENGULFING");
    }
    
    return patterns;
}

// 🔧 UPDATED: Improved smartStopLoss function with optimized stops
function smartStopLoss(data, signalType, confidence) {
    return optimizedStopLoss(data, signalType, confidence, data[data.length-1].close);
}

/* -------------------------
   ENHANCED TREND SIGNAL GENERATION
   ------------------------- */
function generateEnhancedTrendSignal(data, riskLevel, tpMultiplier) {
    if(!data || data.length < 50) return { 
        signal:"HOLD", 
        entry: data.length > 0 ? data[data.length-1].close : 0, 
        tp: 0, sl: 0, confidence:0, rr: 0
    };

    const last = data[data.length-1];
    const lastClose = last.close;

    // Enhanced indicators
    const rsi = advancedRSI(data);
    const currentRsi = rsi[rsi.length-1];
    
    const sma20 = SMA(data, 20);
    const sma50 = SMA(data, 50);
    const sma100 = SMA(data, 100);
    
    const volumeAnalysis = volumeConfirmation(data);
    const regimeAnalysis = enhancedMarketRegimeDetection(data);
    const patterns = enhancedPatternDetection(data);
    
    // Trend detection
    const trendAnalysis = detectTrendType(data);
    const retracementAnalysis = detectRetracement(data, trendAnalysis);
    const fvGaps = detectFairValueGaps(data);

    let buySignals = 0;
    let sellSignals = 0;
    let totalSignals = 0;
    let confirmations = [];

    // RSI signals
    if (currentRsi !== null) {
        totalSignals++;
        if (currentRsi < 30) {
            buySignals += 2;
            confirmations.push(`RSI Oversold (${currentRsi.toFixed(1)})`);
        } else if (currentRsi > 70) {
            sellSignals += 2;
            confirmations.push(`RSI Overbought (${currentRsi.toFixed(1)})`);
        }
    }

    // Moving average signals
    if (sma20[sma20.length-1] && sma50[sma50.length-1]) {
        totalSignals += 2;
        if (sma20[sma20.length-1] > sma50[sma50.length-1]) {
            buySignals += 2;
            confirmations.push("Bullish MA Alignment");
        } else {
            sellSignals += 2;
            confirmations.push("Bearish MA Alignment");
        }
    }

    // Volume confirmation
    totalSignals += 2;
    if (volumeAnalysis.score > 0) {
        buySignals += volumeAnalysis.score;
        confirmations.push(`Volume ${volumeAnalysis.strength}`);
    } else if (volumeAnalysis.score < 0) {
        sellSignals += Math.abs(volumeAnalysis.score);
        confirmations.push(`Volume ${volumeAnalysis.strength}`);
    }

    // Calculate confidence
    const rawConfidence = totalSignals > 0 ? Math.min(100, (Math.max(buySignals, sellSignals) / totalSignals) * 100) : 0;
    const enhancedConfidence = Math.min(100, rawConfidence * 1.1); // Slight boost

    // Signal determination
    let signal = "HOLD";
    let entry = lastClose;
    let tp = lastClose;
    let sl = lastClose;
    let rr = 0;

    const requiredRatio = 1.5; // Reduced from 1.8 to get more signals
    
    if (buySignals > sellSignals * requiredRatio && enhancedConfidence >= 60) { // Reduced from 65
        signal = "BUY";
        sl = smartStopLoss(data, 'BUY', enhancedConfidence);
        const risk = Math.max(entry - sl, entry * 0.002);
        // 🔧 UPDATED: Dynamic TP based on confidence
        const dynamicTPMultiplier = tpMultiplier * (enhancedConfidence / 100);
        tp = entry + (risk * dynamicTPMultiplier);
    } else if (sellSignals > buySignals * requiredRatio && enhancedConfidence >= 60) { // Reduced from 65
        signal = "SELL";
        sl = smartStopLoss(data, 'SELL', enhancedConfidence);
        const risk = Math.max(sl - entry, entry * 0.002);
        // 🔧 UPDATED: Dynamic TP based on confidence
        const dynamicTPMultiplier = tpMultiplier * (enhancedConfidence / 100);
        tp = entry - (risk * dynamicTPMultiplier);
    }

    rr = signal !== "HOLD" ? tpMultiplier : 0;

    return { 
        signal, 
        entry, 
        tp, 
        sl, 
        confidence: enhancedConfidence, 
        rr, 
        confirmations,
        marketRegime: regimeAnalysis.regime,
        volumeConfirmation: volumeAnalysis.strength,
        patterns,
        trend: trendAnalysis.trend,
        trendStrength: trendAnalysis.strength,
        retracement: retracementAnalysis,
        fvGaps: fvGaps.length
    };
}

/* -------------------------
   NEW: TREND CONFIRMATION SYSTEM
   ------------------------- */

// 🔧 NEW: Enhanced trend confirmation function
function confirmTrendWithMultipleTimeframes(data, currentTimeframe) {
    const trends = [];
    const strengths = [];
    
    // Analyze current timeframe trend
    const currentTrend = detectTrendType(data);
    trends.push(currentTrend.direction);
    strengths.push(currentTrend.strength);
    
    // Check volume confirmation
    const volumeAnalysis = volumeConfirmation(data);
    const volumeSupportsTrend = volumeAnalysis.score > 0;
    
    // Check RSI for overbought/oversold in context of trend
    const rsi = advancedRSI(data);
    const currentRsi = rsi[rsi.length-1];
    
    let rsiConfirmation = true;
    if (currentRsi !== null) {
        if (currentTrend.direction === 'UP' && currentRsi > 70) {
            rsiConfirmation = false;
        } else if (currentTrend.direction === 'DOWN' && currentRsi < 30) {
            rsiConfirmation = false;
        }
    }
    
    // Check if we're trading with the trend
    const isUptrend = currentTrend.direction === 'UP' && currentTrend.strength > 25;
    const isDowntrend = currentTrend.direction === 'DOWN' && currentTrend.strength > 25;
    
    return {
        confirmed: volumeSupportsTrend && rsiConfirmation && (isUptrend || isDowntrend),
        direction: currentTrend.direction,
        strength: currentTrend.strength,
        volumeConfirmed: volumeSupportsTrend,
        rsiConfirmed: rsiConfirmation,
        details: {
            trend: currentTrend,
            volume: volumeAnalysis,
            rsi: currentRsi
        }
    };
}

// 🔧 NEW: Counter-trend trading protection
function isCounterTrendTrade(signal, trendAnalysis) {
    if (signal === 'BUY' && trendAnalysis.direction === 'DOWN' && trendAnalysis.strength > 60) {
        return { isCounterTrend: true, reason: 'Buying in strong downtrend' };
    }
    if (signal === 'SELL' && trendAnalysis.direction === 'UP' && trendAnalysis.strength > 60) {
        return { isCounterTrend: true, reason: 'Selling in strong uptrend' };
    }
    return { isCounterTrend: false, reason: 'Trading with trend' };
}

// 🔧 NEW: Market condition assessment
function assessMarketCondition(data) {
    if (data.length < 100) return "NEUTRAL";
    
    const closes = data.map(c => c.close);
    const recentCloses = closes.slice(-50);
    const olderCloses = closes.slice(-100, -50);
    
    const recentAvg = recentCloses.reduce((a, b) => a + b, 0) / recentCloses.length;
    const olderAvg = olderCloses.reduce((a, b) => a + b, 0) / olderCloses.length;
    
    const trendPercent = (recentAvg - olderAvg) / olderAvg * 100;
    
    if (trendPercent < -15) return "STRONG_DOWNTREND";
    if (trendPercent < -5) return "DOWNTREND";
    if (trendPercent > 15) return "STRONG_UPTREND";
    if (trendPercent > 5) return "UPTREND";
    
    return "NEUTRAL";
}

// 🔧 NEW: Enhanced risk assessment
function calculateTradeRisk(signal, marketCondition, confidence) {
    let riskMultiplier = 1.0;
    
    // Reduce risk in strong trends against our signal
    if ((signal === "BUY" && marketCondition.includes("DOWNTREND")) || 
        (signal === "SELL" && marketCondition.includes("UPTREND"))) {
        riskMultiplier = 0.3; // 70% risk reduction for counter-trend
    }
    
    // Increase risk when trading with strong trends
    if ((signal === "BUY" && marketCondition.includes("UPTREND")) || 
        (signal === "SELL" && marketCondition.includes("DOWNTREND"))) {
        riskMultiplier = 1.2; // 20% risk increase for trend-following
    }
    
    // Adjust based on confidence
    riskMultiplier *= (confidence / 100);
    
    return Math.max(0.1, Math.min(2.0, riskMultiplier));
}

/* -------------------------
   NEW: ERROR HANDLING & RECOVERY SYSTEM
   ------------------------- */
function logError(error, context = 'Unknown') {
    errorCount++;
    consecutiveErrors++;
    performanceMetrics.errorsEncountered++;
    
    const errorDetails = {
        timestamp: new Date().toISOString(),
        context: context,
        error: error.message || String(error),
        stack: error.stack || 'No stack trace'
    };
    
    console.error(`❌ [${context}] Error:`, error);
    
    // Update UI
    document.getElementById('error-count').textContent = errorCount;
    document.getElementById('error-count').style.color = errorCount > 0 ? '#ff4444' : '#cccccc';
    
    // Add to error log
    const errorLog = document.getElementById('error-log');
    if (errorLog) {
        const errorEntry = document.createElement('div');
        errorEntry.style.padding = '5px';
        errorEntry.style.borderBottom = '1px solid #444';
        errorEntry.innerHTML = `
            <strong>${new Date().toLocaleTimeString()}</strong> - ${context}<br>
            <small>${error.message || String(error)}</small>
        `;
        errorLog.prepend(errorEntry);
        
        // Keep only last 10 errors
        if (errorLog.children.length > 10) {
            errorLog.removeChild(errorLog.lastChild);
        }
    }
    
    // Show error panel for significant errors
    if (consecutiveErrors >= 2 || error.message?.includes('WebSocket') || error.message?.includes('API')) {
        showError(error, context);
    }
    
    // Check circuit breaker
    checkCircuitBreaker();
    
    return errorDetails;
}

function showError(error, context) {
    const errorPanel = document.getElementById('error-panel');
    const errorMessage = document.getElementById('error-message');
    const errorDetails = document.getElementById('error-details');
    
    errorMessage.textContent = `${context}: ${error.message || String(error)}`;
    errorDetails.textContent = error.stack || 'No stack trace available';
    
    errorPanel.classList.add('show');
    
    // Auto-hide after 10 seconds for non-critical errors
    if (!error.message?.includes('WebSocket') && !error.message?.includes('API')) {
        setTimeout(() => {
            if (errorPanel.classList.contains('show')) {
                hideError();
            }
        }, 10000);
    }
}

function hideError() {
    document.getElementById('error-panel').classList.remove('show');
}

function showRecovery(message) {
    const recoveryPanel = document.getElementById('recovery-status');
    const recoveryMessage = document.getElementById('recovery-message');
    
    recoveryMessage.textContent = message;
    recoveryPanel.classList.add('show');
}

function hideRecovery() {
    document.getElementById('recovery-status').classList.remove('show');
}

function checkCircuitBreaker() {
    const circuitBreakerMode = document.getElementById('circuit-breaker').value;
    
    if (circuitBreakerMode === 'disabled') return false;
    
    if (consecutiveErrors >= MAX_CONSECUTIVE_ERRORS || errorCount > 20) {
        circuitBreakerTripped = true;
        document.getElementById('circuit-status').textContent = 'TRIPPED';
        document.getElementById('circuit-status').style.color = '#ff4444';
        
        if (isRunning) {
            stopBot();
            showError(new Error('Circuit breaker tripped due to excessive errors'), 'Safety System');
            showRecovery('Circuit breaker activated. Bot stopped for safety.');
        }
        
        return true;
    }
    
    return false;
}

function resetCircuitBreaker() {
    consecutiveErrors = 0;
    circuitBreakerTripped = false;
    document.getElementById('circuit-status').textContent = 'READY';
    document.getElementById('circuit-status').style.color = '#00ff00';
}

async function attemptRecovery() {
    if (recoveryAttempts >= MAX_RECOVERY_ATTEMPTS) {
        showError(new Error('Maximum recovery attempts reached'), 'Recovery System');
        return false;
    }
    
    recoveryAttempts++;
    performanceMetrics.recoveryAttempts++;
    
    showRecovery(`Attempting recovery (${recoveryAttempts}/${MAX_RECOVERY_ATTEMPTS})...`);
    
    try {
        // Stop everything
        if (ws) {
            ws.close();
            ws = null;
        }
        
        // Clear buffers
        candleBuffer = [];
        
        // Reset error counters
        resetCircuitBreaker();
        
        // Wait a bit
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        // Try to restart
        await startBot();
        
        hideRecovery();
        recoveryAttempts = 0;
        return true;
        
    } catch (error) {
        logError(error, 'Recovery Attempt');
        showRecovery(`Recovery failed: ${error.message}`);
        return false;
    }
}

function updatePerformanceMetrics() {
    if (!performanceMetrics.startTime) {
        performanceMetrics.startTime = Date.now();
    }
    
    const uptime = Date.now() - performanceMetrics.startTime;
    const hours = Math.floor(uptime / (1000 * 60 * 60));
    const minutes = Math.floor((uptime % (1000 * 60 * 60)) / (1000 * 60));
    
    // Calculate performance score (0-100%)
    const errorRate = performanceMetrics.errorsEncountered / Math.max(performanceMetrics.signalsGenerated, 1);
    const performanceScore = Math.max(0, 100 - (errorRate * 100));
    
    document.getElementById('performance-score').textContent = `${performanceScore.toFixed(1)}%`;
    document.getElementById('performance-score').style.color = 
        performanceScore > 80 ? '#00ff00' : 
        performanceScore > 60 ? '#ffaa33' : '#ff4444';
    
    // Update performance tab
    const systemHealth = document.getElementById('system-health');
    const performanceStats = document.getElementById('performance-stats');
    const circuitBreakerStatus = document.getElementById('circuit-breaker-status');
    
    if (systemHealth) {
        systemHealth.innerHTML = `
            <div style="color: ${performanceScore > 80 ? '#00ff00' : performanceScore > 60 ? '#ffaa33' : '#ff4444'}">
                ${performanceScore > 80 ? '✅ EXCELLENT' : performanceScore > 60 ? '⚠️ STABLE' : '❌ DEGRADED'}
            </div>
            <div>Uptime: ${hours}h ${minutes}m</div>
            <div>Recovery Attempts: ${performanceMetrics.recoveryAttempts}</div>
        `;
    }
    
    if (performanceStats) {
        performanceStats.innerHTML = `
            <div>Signals: ${performanceMetrics.signalsGenerated}</div>
            <div>Errors: ${performanceMetrics.errorsEncountered}</div>
            <div>WS Reconnects: ${performanceMetrics.wsReconnects}</div>
            <div>Avg Processing: ${performanceMetrics.avgProcessingTime.toFixed(2)}ms</div>
        `;
    }
    
    if (circuitBreakerStatus) {
        circuitBreakerStatus.innerHTML = `
            <div>Status: <span style="color: ${circuitBreakerTripped ? '#ff4444' : '#00ff00'}">${circuitBreakerTripped ? 'TRIPPED' : 'READY'}</span></div>
            <div>Consecutive Errors: ${consecutiveErrors}/${MAX_CONSECUTIVE_ERRORS}</div>
            <div>Total Errors: ${errorCount}</div>
        `;
    }
    
    performanceMetrics.lastHealthCheck = Date.now();
}

/* -------------------------
   NEW: ADAPTIVE STRATEGY DETECTION
   ------------------------- */
function analyzeMarketConditions(data) {
    if (data.length < 20) return null;
    
    const trendAnalysis = detectTrendType(data);
    const volatility = calculateVolatility(data);
    const volumeProfile = analyzeVolumeProfile(data);
    const regimeAnalysis = enhancedMarketRegimeDetection(data);
    const rangeSize = calculateRangeSize(data);
    
    return {
        trend: trendAnalysis.trend,
        trendStrength: trendAnalysis.strength,
        volatility: volatility,
        volume: volumeProfile,
        regime: regimeAnalysis.regime,
        rangeSize: rangeSize,
        isSessionStart: isSessionStart(),
        hasOrderBlocks: detectOrderBlocks(data).length > 0,
        hasLiquiditySweeps: detectLiquiditySweeps(data).length > 0,
        hasCRTSetup: detectCRTSetup(data).valid
    };
}

function calculateStrategyScores(marketConditions) {
    const scores = {
        enhanced: 0,
        crt: 0,
        orb: 0,
        smc: 0
    };
    
    const weights = enhancedConfig.adaptiveWeights[marketConditions.regime] || 
                   enhancedConfig.adaptiveWeights.NEUTRAL;
    
    // Enhanced Trend Strategy Scoring
    if (marketConditions.trendStrength > enhancedConfig.strategyConditions.enhanced.minTrendStrength &&
        marketConditions.volatility < enhancedConfig.strategyConditions.enhanced.maxVolatility) {
        scores.enhanced = weights.enhanced * 100;
        // 🔧 UPDATED: Bonus for strong trends (from backtest optimization)
        if (marketConditions.trendStrength > 40) scores.enhanced += 25;
    }
    
    // CRT Strategy Scoring
    if (marketConditions.rangeSize > enhancedConfig.strategyConditions.crt.minRangeSize &&
        marketConditions.volatility < enhancedConfig.strategyConditions.crt.maxVolatility) {
        scores.crt = weights.crt * 100;
        // Bonus for valid CRT setup
        if (marketConditions.hasCRTSetup) scores.crt += 30;
    }
    
    // ORB Strategy Scoring
    if (marketConditions.isSessionStart && 
        marketConditions.rangeSize > enhancedConfig.strategyConditions.orb.minRangeSize) {
        scores.orb = weights.orb * 100;
        // Bonus for high volume
        if (marketConditions.volume > enhancedConfig.strategyConditions.orb.volumeMultiplier) {
            scores.orb += 25;
        }
    }
    
    // SMC Strategy Scoring
    if (marketConditions.hasOrderBlocks && marketConditions.hasLiquiditySweeps) {
        scores.smc = weights.smc * 100;
        // Bonus for multiple setups
        if (marketConditions.hasOrderBlocks > 1) scores.smc += 15;
        if (marketConditions.hasLiquiditySweeps > 2) scores.smc += 15;
    }
    
    // Volume adjustments
    Object.keys(scores).forEach(strategy => {
        if (scores[strategy] > 0) {
            const volumeMultiplier = enhancedConfig.strategyConditions[strategy].volumeMultiplier;
            if (marketConditions.volume > volumeMultiplier) {
                scores[strategy] *= 1.2;
            }
        }
    });
    
    // Ensure scores are within 0-100 range
    Object.keys(scores).forEach(strategy => {
        scores[strategy] = Math.min(100, Math.max(0, scores[strategy]));
    });
    
    return scores;
}

function selectBestStrategy(scores) {
    let bestStrategy = "enhanced"; // Default fallback
    let highestScore = 0;
    
    for (const [strategy, score] of Object.entries(scores)) {
        if (score > highestScore && score > 40) { // Minimum threshold
            highestScore = score;
            bestStrategy = strategy;
        }
    }
    
    return {
        strategy: bestStrategy,
        score: highestScore,
        allScores: scores
    };
}

function adaptiveStrategySelection(data) {
    const marketConditions = analyzeMarketConditions(data);
    if (!marketConditions) return { strategy: "enhanced", score: 0, allScores: {} };
    
    const scores = calculateStrategyScores(marketConditions);
    const bestStrategy = selectBestStrategy(scores);
    
    // Store for display
    strategyScores = scores;
    
    return {
        ...bestStrategy,
        marketConditions: marketConditions
    };
}

/* -------------------------
   STRATEGY-SPECIFIC FUNCTIONS
   ------------------------- */
function getCurrentSession() {
    const now = new Date();
    const utcHours = now.getUTCHours();
    
    if (utcHours >= TRADING_SESSIONS.NEWYORK.start && utcHours < TRADING_SESSIONS.NEWYORK.end) {
        return 'NEWYORK';
    } else if (utcHours >= TRADING_SESSIONS.LONDON.start && utcHours < TRADING_SESSIONS.LONDON.end) {
        return 'LONDON';
    } else if (utcHours >= TRADING_SESSIONS.ASIAN.start && utcHours < TRADING_SESSIONS.ASIAN.end) {
        return 'ASIAN';
    } else {
        return 'ASIAN'; // Default to Asian if between sessions
    }
}

function isSessionStart() {
    const now = new Date();
    const utcHours = now.getUTCHours();
    const utcMinutes = now.getUTCMinutes();
    const currentSession = getCurrentSession();
    
    // Check if we're at the start of a session (first 15 minutes)
    if (currentSession === 'NEWYORK' && utcHours === TRADING_SESSIONS.NEWYORK.start && utcMinutes < 15) {
        return true;
    } else if (currentSession === 'LONDON' && utcHours === TRADING_SESSIONS.LONDON.start && utcMinutes < 15) {
        return true;
    } else if (currentSession === 'ASIAN' && utcHours === TRADING_SESSIONS.ASIAN.start && utcMinutes < 15) {
        return true;
    }
    
    return false;
}

function calculateRangeSize(data, lookback = 10) {
    if (data.length < lookback) return 0;
    
    const recentData = data.slice(-lookback);
    const high = Math.max(...recentData.map(c => c.high));
    const low = Math.min(...recentData.map(c => c.low));
    const range = high - low;
    const avgPrice = (high + low) / 2;
    
    return range / avgPrice; // Return as percentage
}

function setupORBLevels(data) {
    if (data.length < 2) return null;
    
    const firstCandle = data[data.length - 1];
    return {
        ORH: firstCandle.high,
        ORL: firstCandle.low,
        session: getCurrentSession(),
        timestamp: Date.now()
    };
}

function detectCRTSetup(data) {
    if (data.length < 5) return { valid: false, reason: "Not enough data" };
    
    // Look for the 3-candle CRT pattern
    for (let i = 3; i < data.length; i++) {
        const candle1 = data[i-2]; // First candle (basis)
        const candle2 = data[i-1]; // Second candle (liquidity sweep)
        const candle3 = data[i];   // Third candle (entry)
        
        const CRH = candle1.high;
        const CRL = candle1.low;
        
        // Check for liquidity sweep on candle2
        const sweepUp = candle2.high > CRH * (1 + 0.001);
        const sweepDown = candle2.low < CRL * (1 - 0.001);
        
        if (sweepUp || sweepDown) {
            // Look for FVG after sweep
            const fvGaps = detectFairValueGaps(data.slice(0, i+1));
            const recentFVG = fvGaps[fvGaps.length - 1];
            
            if (recentFVG) {
                const direction = sweepUp ? 'BEARISH' : 'BULLISH';
                
                // Check if current price is touching FVG
                const currentPrice = data[data.length-1].close;
                const isTouchingFVG = isPriceInFVG(currentPrice, recentFVG);
                
                if (isTouchingFVG && recentFVG.direction === direction) {
                    return {
                        valid: true,
                        direction: sweepUp ? 'SELL' : 'BUY',
                        CRH: CRH,
                        CRL: CRL,
                        entry: currentPrice,
                        confidence: 75 * 1.2,
                        fvg: recentFVG
                    };
                }
            }
        }
    }
    
    return { valid: false, reason: "No valid CRT setup found" };
}

function generateORBSignal(data, orbLevels) {
    if (!orbLevels) return { signal: "HOLD", confidence: 0, strategy: "ORB" };
    
    const currentPrice = data[data.length-1].close;
    const previousPrice = data[data.length-2].close;
    
    // Check for breakout
    if (currentPrice > orbLevels.ORH && previousPrice <= orbLevels.ORH) {
        return { 
            signal: "BUY", 
            confidence: 70,
            strategy: "ORB Breakout",
            entry: currentPrice,
            orbLevels: orbLevels
        };
    } else if (currentPrice < orbLevels.ORL && previousPrice >= orbLevels.ORL) {
        return { 
            signal: "SELL", 
            confidence: 70,
            strategy: "ORB Breakout",
            entry: currentPrice,
            orbLevels: orbLevels
        };
    }
    
    // Check for retest
    if (Math.abs(currentPrice - orbLevels.ORH) / orbLevels.ORH < 0.001) {
        return { 
            signal: "SELL", 
            confidence: 75,
            strategy: "ORB Retest",
            entry: currentPrice,
            orbLevels: orbLevels
        };
    } else if (Math.abs(currentPrice - orbLevels.ORL) / orbLevels.ORL < 0.001) {
        return { 
            signal: "BUY", 
            confidence: 75,
            strategy: "ORB Retest",
            entry: currentPrice,
            orbLevels: orbLevels
        };
    }
    
    return { signal: "HOLD", confidence: 0, strategy: "ORB" };
}

function detectOrderBlocks(data) {
    const orderBlocks = [];
    if (data.length < 10) return orderBlocks;
    
    // Look for consolidation followed by impulse move
    for (let i = 5; i < data.length - 1; i++) {
        const consolidationRange = data.slice(i-5, i);
        const impulseCandle = data[i];
        
        // Check if we had consolidation (small range candles)
        const consolidationHigh = Math.max(...consolidationRange.map(c => c.high));
        const consolidationLow = Math.min(...consolidationRange.map(c => c.low));
        const consolidationRangeSize = (consolidationHigh - consolidationLow) / consolidationLow;
        
        if (consolidationRangeSize < 0.005) { // Less than 0.5% range
            // Check for impulse move
            const impulseSize = Math.abs(impulseCandle.close - impulseCandle.open) / impulseCandle.open;
            
            if (impulseSize > 0.01) { // More than 1% impulse
                const isBullish = impulseCandle.close > impulseCandle.open;
                const orderBlock = {
                    type: isBullish ? 'BULLISH' : 'BEARISH',
                    high: consolidationHigh,
                    low: consolidationLow,
                    timestamp: impulseCandle.time,
                    isValid: true
                };
                
                orderBlocks.push(orderBlock);
            }
        }
    }
    
    return orderBlocks.slice(-3); // Return only the 3 most recent order blocks
}

function detectLiquiditySweeps(data) {
    const sweeps = [];
    if (data.length < 10) return sweeps;
    
    // Look for wicks that break previous highs/lows and then reverse
    for (let i = 5; i < data.length; i++) {
        const currentCandle = data[i];
        const previousHigh = Math.max(...data.slice(i-5, i).map(c => c.high));
        const previousLow = Math.min(...data.slice(i-5, i).map(c => c.low));
        
        // Check for liquidity sweep up (wick above previous high that gets rejected)
        if (currentCandle.high > previousHigh && currentCandle.close < currentCandle.open) {
            sweeps.push({
                type: 'UP',
                level: previousHigh,
                timestamp: currentCandle.time,
                candle: currentCandle
            });
        }
        
        // Check for liquidity sweep down (wick below previous low that gets rejected)
        if (currentCandle.low < previousLow && currentCandle.close > currentCandle.open) {
            sweeps.push({
                type: 'DOWN',
                level: previousLow,
                timestamp: currentCandle.time,
                candle: currentCandle
            });
        }
    }
    
    return sweeps.slice(-5); // Return only the 5 most recent sweeps
}

/* -------------------------
   🔧 NEW: IMPROVED SIGNAL FILTERING
   ------------------------- */
function shouldAcceptSignal(signal, marketConditions, confidence) {
    // Reject low confidence signals in volatile markets
    if (marketConditions.regime === 'VOLATILE' && confidence < 75) {
        return false;
    }
    
    // Require higher confidence for counter-trend trades
    const trend = detectTrendType(candleBuffer);
    if ((signal === 'BUY' && trend.direction === 'DOWN') || 
        (signal === 'SELL' && trend.direction === 'UP')) {
        return confidence >= 80;
    }
    
    // Volume confirmation requirement
    const volume = volumeConfirmation(candleBuffer);
    if (volume.strength === 'WEAK' && confidence < 70) {
        return false;
    }
    
    // 🔧 NEW: Session-based filtering
    if (!isOptimalTradingSession()) {
        return confidence >= 75; // Higher threshold for non-optimal sessions
    }
    
    return true;
}

/* -------------------------
   🔧 NEW: DYNAMIC POSITION SIZING
   ------------------------- */
function calculatePositionSize(confidence, marketRegime, accountBalance = 1000) {
    const baseSize = 0.1; // 10% of account
    
    // Adjust based on confidence
    let sizeMultiplier = confidence / 100;
    
    // Adjust based on market regime
    switch(marketRegime) {
        case 'TRENDING':
            sizeMultiplier *= 1.2;
            break;
        case 'VOLATILE':
            sizeMultiplier *= 0.6;
            break;
        case 'RANGING':
            sizeMultiplier *= 0.8;
            break;
    }
    
    const positionSize = accountBalance * baseSize * sizeMultiplier;
    return Math.max(positionSize, accountBalance * 0.05); // Minimum 5%
}

/* -------------------------
   🔧 NEW: OPTIMAL TRADING SESSION CHECK
   ------------------------- */
function isOptimalTradingSession() {
    const session = getCurrentSession();
    // Focus on London & New York overlap (13-16 UTC)
    const now = new Date();
    const utcHours = now.getUTCHours();
    return session === 'LONDON' || session === 'NEWYORK' || (utcHours >= 13 && utcHours < 16);
}

/* -------------------------
   🔧 UPDATED: ENHANCED TRADE MANAGEMENT
   ------------------------- */

function openNewTrade(signal, entry, tp, sl, confidence, marketRegime, trend, volumeConfirmation, patterns, strategy, adaptiveScore) {
    const riskMultiplier = getRiskMultiplier();
    const positionSize = calculatePositionSize(confidence, marketRegime, 1000) * riskMultiplier;
    
    activeTrade = {
        signal: signal,
        entry: entry,
        tp: tp,
        sl: sl,
        confidence: confidence,
        marketRegime: marketRegime,
        trend: trend,
        volumeConfirmation: volumeConfirmation,
        patterns: patterns,
        strategy: strategy,
        adaptiveScore: adaptiveScore,
        openTime: new Date(),
        open: true,
        result: "OPEN",
        positionSize: positionSize,
        riskMultiplier: riskMultiplier
    };
    
    // Update UI
    document.getElementById("trade-status").textContent = "ACTIVE TRADE";
    document.getElementById("trade-status").className = "trade-status active";
    
    updateActiveTradeUI(entry, 0, "OPEN");
    
    console.log(`🔄 New ${signal} trade opened at ${entry} using ${strategy} strategy (Risk: ${(riskMultiplier * 100).toFixed(0)}%)`);
}

function closeActiveTrade(result, exitPrice) {
    if (!activeTrade) return;
    
    activeTrade.open = false;
    activeTrade.closeTime = new Date();
    activeTrade.result = result;
    activeTrade.exitPrice = exitPrice;
    
    // Calculate P/L
    let plPercent = 0;
    if (activeTrade.signal === "BUY") {
        plPercent = ((exitPrice - activeTrade.entry) / activeTrade.entry) * 100;
    } else {
        plPercent = ((activeTrade.entry - exitPrice) / activeTrade.entry) * 100;
    }
    activeTrade.plPercent = plPercent;
    
    // 🔧 NEW: Update loss prevention system
    updateLossPrevention(result, plPercent);
    
    // Add to history
    tradeHistory.push({...activeTrade});
    
    // Update UI
    document.getElementById("trade-status").textContent = "TRADE CLOSED: " + result;
    document.getElementById("trade-status").className = "trade-status inactive";
    
    // Log the closed trade
    logTradeClose(activeTrade);
    
    console.log(`🔒 Trade closed: ${result} at ${exitPrice} (P/L: ${plPercent.toFixed(2)}%)`);
    
    // Reset active trade
    activeTrade = null;
    
    // Play sound for trade closure
    document.getElementById("alert-sound").play();
}

function checkActiveTrade() {
    if (!activeTrade || !activeTrade.open) return;
    
    const currentPrice = candleBuffer.length > 0 ? candleBuffer[candleBuffer.length-1].close : activeTrade.entry;
    let result = "OPEN";
    let plPercent = 0;
    
    if (activeTrade.signal === "BUY") {
        plPercent = ((currentPrice - activeTrade.entry) / activeTrade.entry) * 100;
        
        if (currentPrice >= activeTrade.tp) {
            result = "TP HIT";
            closeActiveTrade("TP HIT", currentPrice);
        } else if (currentPrice <= activeTrade.sl) {
            result = "SL HIT";
            closeActiveTrade("SL HIT", currentPrice);
        }
    } else if (activeTrade.signal === "SELL") {
        plPercent = ((activeTrade.entry - currentPrice) / activeTrade.entry) * 100;
        
        if (currentPrice <= activeTrade.tp) {
            result = "TP HIT";
            closeActiveTrade("TP HIT", currentPrice);
        } else if (currentPrice >= activeTrade.sl) {
            result = "SL HIT";
            closeActiveTrade("SL HIT", currentPrice);
        }
    }
    
    // Update active trade UI
    updateActiveTradeUI(currentPrice, plPercent, result);
}

function updateActiveTradeUI(currentPrice, plPercent, result) {
    if (!activeTrade) return;
    
    document.getElementById("active-trade-signal").textContent = activeTrade.signal;
    document.getElementById("active-trade-entry").textContent = activeTrade.entry.toFixed(5);
    document.getElementById("active-trade-tp").textContent = activeTrade.tp.toFixed(5);
    document.getElementById("active-trade-sl").textContent = activeTrade.sl.toFixed(5);
    
    const plColor = plPercent >= 0 ? "#00ff00" : "#ff4444";
    document.getElementById("active-trade-pl").innerHTML = `<span style="color: ${plColor}">${plPercent.toFixed(2)}%</span>`;
    document.getElementById("active-trade-result").textContent = result;
}

/* -------------------------
   UPDATED UI FUNCTIONS FOR ADAPTIVE STRATEGY
   ------------------------- */
function updateStrategyAnalysis(marketConditions, strategySelection) {
    if (!marketConditions || !strategySelection) return;
    
    // Update Strategy Scores
    let scoresHtml = '';
    for (const [strategy, score] of Object.entries(strategySelection.allScores)) {
        const scoreColor = score > 70 ? '#00ff00' : score > 40 ? '#ffaa33' : '#ff4444';
        scoresHtml += `<div style="margin: 5px 0;">
            <span style="text-transform: uppercase; font-weight: bold;">${strategy}:</span>
            <span style="color: ${scoreColor}; margin-left: 10px;">${score.toFixed(1)}</span>
        </div>`;
    }
    document.getElementById('strategy-scores').innerHTML = scoresHtml;
    
    // Update Market Conditions
    const conditionsHtml = `
        <div><strong>Regime:</strong> ${marketConditions.regime}</div>
        <div><strong>Trend:</strong> ${marketConditions.trend} (${marketConditions.trendStrength.toFixed(1)}%)</div>
        <div><strong>Volatility:</strong> ${(marketConditions.volatility * 100).toFixed(2)}%</div>
        <div><strong>Volume:</strong> ${marketConditions.volume.toFixed(2)}x avg</div>
        <div><strong>Range Size:</strong> ${(marketConditions.rangeSize * 100).toFixed(2)}%</div>
    `;
    document.getElementById('market-conditions').innerHTML = conditionsHtml;
    
    // Update Strategy Triggers
    const triggersHtml = `
        <div><strong>Session Start:</strong> ${marketConditions.isSessionStart ? '✅' : '❌'}</div>
        <div><strong>Order Blocks:</strong> ${marketConditions.hasOrderBlocks ? '✅' : '❌'}</div>
        <div><strong>Liquidity Sweeps:</strong> ${marketConditions.hasLiquiditySweeps ? '✅' : '❌'}</div>
        <div><strong>CRT Setup:</strong> ${marketConditions.hasCRTSetup ? '✅' : '❌'}</div>
    `;
    document.getElementById('strategy-triggers').innerHTML = triggersHtml;
    
    // Update Adaptive Logic
    const logicHtml = `
        <div><strong>Selected Strategy:</strong> <span class="strategy-indicator strategy-${strategySelection.strategy}">${strategySelection.strategy.toUpperCase()}</span></div>
        <div><strong>Selection Score:</strong> ${strategySelection.score.toFixed(1)}</div>
        <div><strong>Reason:</strong> ${getStrategySelectionReason(marketConditions, strategySelection)}</div>
    `;
    document.getElementById('adaptive-logic').innerHTML = logicHtml;
}

function getStrategySelectionReason(marketConditions, strategySelection) {
    const strategy = strategySelection.strategy;
    
    switch(strategy) {
        case 'enhanced':
            return `Strong trend (${marketConditions.trendStrength.toFixed(1)}%) with manageable volatility`;
        case 'crt':
            return `Clear range formation (${(marketConditions.rangeSize * 100).toFixed(2)}%) with valid setup`;
        case 'orb':
            return `Session start with consolidation pattern`;
        case 'smc':
            return `Smart Money activity detected with order blocks & liquidity sweeps`;
        default:
            return 'Market conditions suitable for this strategy';
    }
}

function switchTab(tabName) {
    document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
    document.querySelectorAll('.tab-panel').forEach(panel => panel.style.display = 'none');
    
    if (tabName === 'chart') {
        document.querySelectorAll('.tab-button')[0].classList.add('active');
        document.getElementById('chart-tab').style.display = 'block';
    } else if (tabName === 'trades') {
        document.querySelectorAll('.tab-button')[1].classList.add('active');
        document.getElementById('trades-tab').style.display = 'block';
    } else if (tabName === 'analysis') {
        document.querySelectorAll('.tab-button')[2].classList.add('active');
        document.getElementById('analysis-tab').style.display = 'block';
        if (candleBuffer.length > 0) {
            updateMarketAnalysis(candleBuffer);
        }
    } else if (tabName === 'strategy') {
        document.querySelectorAll('.tab-button')[3].classList.add('active');
        document.getElementById('strategy-tab').style.display = 'block';
        if (candleBuffer.length > 0) {
            const marketConditions = analyzeMarketConditions(candleBuffer);
            const strategySelection = adaptiveStrategySelection(candleBuffer);
            updateStrategyAnalysis(marketConditions, strategySelection);
        }
    } else if (tabName === 'performance') {
        document.querySelectorAll('.tab-button')[4].classList.add('active');
        document.getElementById('performance-tab').style.display = 'block';
        updatePerformanceMetrics();
    }
}

function updateMarketAnalysis(data) {
    if (!data || data.length < 20) return;
    
    const volumeAnalysis = volumeConfirmation(data);
    const regimeAnalysis = enhancedMarketRegimeDetection(data);
    const trendStrength = calculateTrendStrength(data);
    const patterns = enhancedPatternDetection(data);
    const supports = findSupportResistance(data).support;
    const resistances = findSupportResistance(data).resistance;
    const trendAnalysis = detectTrendType(data);
    const retracementAnalysis = detectRetracement(data, trendAnalysis);
    const fvGaps = detectFairValueGaps(data);
    
    document.getElementById('volume-analysis').innerHTML = 
        `<span style="color: ${volumeAnalysis.score > 0 ? '#00ff00' : volumeAnalysis.score < 0 ? '#ff4444' : '#cccccc'}">
         ${volumeAnalysis.strength} (${volumeAnalysis.ratio.toFixed(2)}x avg)</span>`;
    
    document.getElementById('trend-strength').innerHTML = 
        `<span style="color: ${trendAnalysis.strength > 50 ? '#00ff00' : trendAnalysis.strength > 20 ? '#ffff00' : '#ff4444'}">
         ${trendAnalysis.trend} (${trendAnalysis.strength.toFixed(1)}%)</span>`;
    
    document.getElementById('support-resistance').innerHTML = 
        `S: ${supports.length > 0 ? supports[supports.length-1].toFixed(2) : 'N/A'} | 
         R: ${resistances.length > 0 ? resistances[resistances.length-1].toFixed(2) : 'N/A'}`;
    
    document.getElementById('pattern-detection').innerHTML = 
        `${patterns.length > 0 ? patterns.join(', ') : 'No significant patterns'} | 
         FVG: ${fvGaps.length} | 
         Retrace: ${retracementAnalysis.isRetracement ? (retracementAnalysis.completion * 100).toFixed(1) + '%' : 'No'}`;
    
    document.getElementById('current-regime').textContent = regimeAnalysis.regime;
    document.getElementById('current-regime').style.color = 
        regimeAnalysis.regime === 'TRENDING' ? '#00ff00' : 
        regimeAnalysis.regime === 'VOLATILE' ? '#ff4444' : 
        regimeAnalysis.regime === 'RANGING' ? '#ffff00' : '#cccccc';
        
    document.getElementById('trend-direction').textContent = trendAnalysis.direction;
    document.getElementById('trend-direction').style.color = 
        trendAnalysis.direction === 'UP' ? '#00ff00' : 
        trendAnalysis.direction === 'DOWN' ? '#ff4444' : '#ffff00';
}

/* -------------------------
   CORE BOT FUNCTIONS WITH ENHANCED ERROR HANDLING AND BITGET SUPPORT
   ------------------------- */
async function startBot(){
  if(isRunning) return;
  
  try {
    isRunning = true;
    const symbol = document.getElementById("symbol").value.toUpperCase();
    const interval = document.getElementById("timeframe").value;
    const strategy = document.getElementById("trading-strategy").value;
    const exchange = document.getElementById("exchange").value;
    
    // Reset error counters on fresh start
    resetCircuitBreaker();
    
    // Update status indicators
    document.getElementById("status").textContent = "RUNNING";
    document.getElementById("status").style.color = "#00ff00";
    document.getElementById("api-status").textContent = "🔄 Testing API...";
    document.getElementById("api-status").style.color = "#ffaa33";
    document.getElementById("active-strategy").textContent = strategy;
    document.getElementById("active-strategy").className = `strategy-indicator strategy-${strategy.toLowerCase()}`;
    document.getElementById("recover-btn").style.display = "none";

    // Test API connection first with timeout
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 10000);
      
      let testUrl;
      if (exchange === 'bitget') {
        testUrl = 'https://api.bitget.com/api/spot/v1/market/tickers';
      } else {
        testUrl = 'https://api.binance.com/api/v3/ping';
      }
      
      const testRes = await fetch(testUrl, {
        signal: controller.signal
      });
      clearTimeout(timeoutId);
      
      if (!testRes.ok) throw new Error(`${exchange} API unavailable`);
      document.getElementById("api-status").textContent = `✅ ${exchange.toUpperCase()} API Connected`;
      document.getElementById("api-status").style.color = "#00ff00";
    } catch (error) {
      throw new Error(`API test failed: ${error.message}`);
    }

    // Preload historic candles with error handling
    try {
      document.getElementById("api-status").textContent = "🔄 Loading data...";
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 15000);
      
      const endpoints = getExchangeEndpoints(exchange, symbol, interval);
      const res = await fetch(endpoints.historical, {
        signal: controller.signal
      });
      clearTimeout(timeoutId);
      
      if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`);
      
      const hist = await res.json();
      if (!Array.isArray(hist.data) && !Array.isArray(hist)) throw new Error("Invalid response format");
      
      // Parse data based on exchange
      const rawData = hist.data || hist;
      candleBuffer = rawData.map(k => parseCandleData(exchange, k));
      if(!Array.isArray(candleBuffer)) candleBuffer = [];
      
      document.getElementById("candle-count").textContent = candleBuffer.length;
      document.getElementById("api-status").textContent = "✅ Data loaded";
    } catch (err) {
      throw new Error(`Failed to fetch historical candles: ${err.message}`);
    }

    analyzeLive();
    updateChart();

    // Open websocket for live kline updates with enhanced error handling
    if(ws) {
      try { ws.close(); } catch(e) { console.warn('Error closing previous WS:', e); }
    }
    
    document.getElementById("ws-status").textContent = "🔄 Connecting...";
    document.getElementById("ws-status").style.color = "#ffaa33";
    
    setupWebSocket(exchange, symbol, interval);
    
  } catch (error) {
    const errorDetails = logError(error, 'Start Bot');
    document.getElementById("status").textContent = "ERROR";
    document.getElementById("status").style.color = "#ff4444";
    document.getElementById("api-status").textContent = "❌ Connection Failed";
    document.getElementById("api-status").style.color = "#ff4444";
    document.getElementById("recover-btn").style.display = "block";
    isRunning = false;
    
    // Auto-recovery for certain errors
    if (!error.message.includes('symbol') && !error.message.includes('Invalid')) {
      setTimeout(() => {
        if (!isRunning && recoveryAttempts < MAX_RECOVERY_ATTEMPTS) {
          attemptRecovery();
        }
      }, 5000);
    }
  }
}

function setupWebSocket(exchange, symbol, interval) {
  try {
    const endpoints = getExchangeEndpoints(exchange, symbol, interval);
    ws = new WebSocket(endpoints.websocket);
    
    // Set timeout for connection
    const connectionTimeout = setTimeout(() => {
      if (ws.readyState !== WebSocket.OPEN) {
        logError(new Error('WebSocket connection timeout'), 'WebSocket Setup');
        ws.close();
      }
    }, 10000);
    
    ws.onmessage = (e) => {
      try {
        const candle = parseWebSocketData(exchange, e);
        if (!candle) return;

        // Reset consecutive errors on successful message
        consecutiveErrors = Math.max(0, consecutiveErrors - 1);

        // replace last forming candle or push if empty
        if(candleBuffer.length === 0) candleBuffer.push(candle);
        else candleBuffer[candleBuffer.length-1] = candle;

        // when candle closes, push a new placeholder (so next updates replace it)
        if(candle.isClosed){
          candleBuffer[candleBuffer.length-1] = candle;
          candleBuffer.push(candle);
          if(candleBuffer.length > BUFFER_SIZE) candleBuffer.shift();
          document.getElementById("candle-count").textContent = candleBuffer.length;
        }

        analyzeLive();
        updateChart();
      } catch (error) {
        logError(error, 'WebSocket Message Processing');
      }
    };

    ws.onopen = () => { 
      clearTimeout(connectionTimeout);
      console.info("WS open"); 
      performanceMetrics.wsReconnects++;
      
      // Send subscribe message for Bitget
      if (exchange === 'bitget') {
        const subscribeMsg = getWebSocketSubscribeMessage(exchange, symbol, interval);
        if (subscribeMsg) {
          ws.send(subscribeMsg);
        }
      }
      
      document.getElementById("ws-status").textContent = "✅ Connected";
      document.getElementById("ws-status").style.color = "#00ff00";
      resetCircuitBreaker();
    };
    
    ws.onerror = (err) => { 
      clearTimeout(connectionTimeout);
      console.error("WS error", err); 
      logError(new Error('WebSocket connection error'), 'WebSocket');
      document.getElementById("ws-status").textContent = "❌ Error";
      document.getElementById("ws-status").style.color = "#ff4444";
    };
    
    ws.onclose = (event) => { 
      clearTimeout(connectionTimeout);
      console.info("WS closed", event.code, event.reason); 
      document.getElementById("ws-status").textContent = "❌ Disconnected";
      document.getElementById("ws-status").style.color = "#ff4444";
      
      // Auto-reconnect if not manually stopped
      if (isRunning && !circuitBreakerTripped) {
        setTimeout(() => {
          if (isRunning) {
            console.log("🔄 Attempting WebSocket reconnection...");
            const exchange = document.getElementById("exchange").value;
            const symbol = document.getElementById("symbol").value.toUpperCase();
            const interval = document.getElementById("timeframe").value;
            setupWebSocket(exchange, symbol, interval);
          }
        }, 3000);
      }
    };
    
  } catch (error) {
    logError(error, 'WebSocket Initialization');
    document.getElementById("ws-status").textContent = "❌ Failed";
    document.getElementById("ws-status").style.color = "#ff4444";
  }
}

function stopBot(){
  isRunning = false;
  if(ws){ 
    try{ 
      ws.close(); 
    } catch(e){
      logError(e, 'Stop Bot - WS Close');
    }
  }
  document.getElementById("status").textContent = "STOPPED";
  document.getElementById("status").style.color = "#ff4444";
  document.getElementById("recover-btn").style.display = "none";
}

function analyzeLive(){
  if (circuitBreakerTripped) {
    console.warn('Circuit breaker tripped - skipping analysis');
    return;
  }
  
  const startTime = performance.now();
  
  try {
    if(candleBuffer.length < 30) {
      console.log("Not enough data for enhanced analysis:", candleBuffer.length);
      return;
    }
    
    // Check active trade first
    if (activeTrade && activeTrade.open) {
      checkActiveTrade();
      
      // Don't generate new signals while a trade is active
      const lastSig = generateEnhancedSignal(candleBuffer, document.getElementById("risk-level").value, parseFloat(document.getElementById("tp-multiplier").value));
      
      // Update UI with current signal (but don't act on it)
      document.getElementById("signal-type").textContent = "ACTIVE TRADE";
      document.getElementById("signal-type").className = "hold";
      document.getElementById("entry-price").textContent = activeTrade.entry ? activeTrade.entry.toFixed(5) : "-";
      document.getElementById("tp-price").textContent = activeTrade.tp ? activeTrade.tp.toFixed(5) : "-";
      document.getElementById("sl-price").textContent = activeTrade.sl ? activeTrade.sl.toFixed(5) : "-";
      document.getElementById("risk-reward").textContent = activeTrade.rr ? `1:${activeTrade.rr.toFixed(2)}` : "-";
      document.getElementById("volume-confirmation").textContent = activeTrade.volumeConfirmation;
      document.getElementById("market-regime").textContent = activeTrade.marketRegime;
      document.getElementById("trend-type").textContent = activeTrade.trend;
      document.getElementById("strategy-type").innerHTML = `${activeTrade.strategy} <span class="strategy-indicator strategy-${activeTrade.strategy.toLowerCase()}">${activeTrade.strategy}</span>`;
      document.getElementById("adaptive-score").textContent = activeTrade.adaptiveScore ? activeTrade.adaptiveScore.toFixed(1) : "-";
      
      document.getElementById("confidence-fill").style.width = `${activeTrade.confidence}%`;
      document.getElementById("confidence-fill").textContent = `${activeTrade.confidence.toFixed(1)}%`;
      document.getElementById("confidence-text").textContent = `Confidence: ${activeTrade.confidence.toFixed(1)}%`;
      
      return;
    }
    
    const risk = document.getElementById("risk-level").value;
    const tpMultiplier = parseFloat(document.getElementById("tp-multiplier").value);
    const symbol = document.getElementById("symbol").value.toUpperCase();
    const sig = generateEnhancedSignal(candleBuffer, risk, tpMultiplier);

    // Update enhanced UI
    document.getElementById("signal-type").textContent = sig.signal;
    document.getElementById("signal-type").className = sig.signal.toLowerCase();
    document.getElementById("entry-price").textContent = sig.entry ? sig.entry.toFixed(5) : "-";
    document.getElementById("tp-price").textContent = sig.tp ? sig.tp.toFixed(5) : "-";
    document.getElementById("sl-price").textContent = sig.sl ? sig.sl.toFixed(5) : "-";
    document.getElementById("risk-reward").textContent = sig.rr ? `1:${sig.rr.toFixed(2)}` : "-";
    document.getElementById("volume-confirmation").textContent = sig.volumeConfirmation;
    document.getElementById("market-regime").textContent = sig.marketRegime;
    document.getElementById("trend-type").textContent = sig.trend;
    document.getElementById("strategy-type").innerHTML = `${sig.strategy} <span class="strategy-indicator strategy-${sig.strategy.toLowerCase()}">${sig.strategy}</span>`;
    document.getElementById("adaptive-score").textContent = sig.adaptiveScore ? sig.adaptiveScore.toFixed(1) : "-";
    
    document.getElementById("confidence-fill").style.width = `${sig.confidence}%`;
    document.getElementById("confidence-fill").textContent = `${sig.confidence.toFixed(1)}%`;
    document.getElementById("confidence-text").textContent = `Confidence: ${sig.confidence.toFixed(1)}%`;

    // Update market analysis
    updateMarketAnalysis(candleBuffer);
    
    // Update strategy analysis
    const marketConditions = analyzeMarketConditions(candleBuffer);
    const strategySelection = adaptiveStrategySelection(candleBuffer);
    updateStrategyAnalysis(marketConditions, strategySelection);

    const currentTime = Date.now();
    
    if(sig.signal !== "HOLD" && sig.confidence >= 60) {
      if(sig.signal !== lastSignal || currentTime - lastSignalTime > SIGNAL_COOLDOWN){
        lastSignal = sig.signal;
        lastSignalTime = currentTime;
        signalCount++;
        performanceMetrics.signalsGenerated++;
        
        document.getElementById("signal-count").textContent = signalCount;
        document.getElementById("active-strategy").textContent = sig.strategy;
        document.getElementById("active-strategy").className = `strategy-indicator strategy-${sig.strategy.toLowerCase()}`;
        
        // Open a trade instead of just logging it
        openNewTrade(
          sig.signal, 
          sig.entry, 
          sig.tp, 
          sig.sl, 
          sig.confidence, 
          sig.marketRegime, 
          sig.trend, 
          sig.volumeConfirmation, 
          sig.patterns,
          sig.strategy,
          sig.adaptiveScore
        );
        
        renderSignalCard(symbol, sig);
        
        if(sig.confidence >= 70) {
          document.getElementById("alert-sound").play();
          document.getElementById("signal-type").style.animation = "pulse 1s infinite";
          setTimeout(() => {
            document.getElementById("signal-type").style.animation = "";
          }, 3000);
        }
        
        console.log(`🔄 Adaptive signal generated: ${sig.signal} | Strategy: ${sig.strategy} | Confidence: ${sig.confidence} | Adaptive Score: ${sig.adaptiveScore}`);
      }
    }
    
    // Update performance metrics
    const processingTime = performance.now() - startTime;
    performanceMetrics.avgProcessingTime = 
      (performanceMetrics.avgProcessingTime * (performanceMetrics.signalsGenerated - 1) + processingTime) / 
      performanceMetrics.signalsGenerated;
      
    updatePerformanceMetrics();
    
  } catch (error) {
    logError(error, 'Live Analysis');
  }
}

function renderSignalCard(symbol, sig) {
  const container = document.getElementById('signals-container');
  
  if (container.innerHTML.includes('Waiting for signals')) {
    container.innerHTML = '';
  }

  const oldLatest = container.querySelector('.signal-card.latest');
  if (oldLatest) oldLatest.classList.remove('latest');

  const div = document.createElement('div');
  div.className = `signal-card ${sig.signal.toLowerCase()} latest`;
  div.innerHTML = `
    <div class="signal-header">${sig.signal} - ${symbol} [${sig.marketRegime}] - ${sig.strategy} <span class="strategy-indicator strategy-${sig.strategy.toLowerCase()}">${sig.strategy}</span></div>
    <div class="signal-meta">${new Date().toLocaleTimeString()} - Conf: ${sig.confidence.toFixed(1)}% | Vol: ${sig.volumeConfirmation} | Adaptive: ${sig.adaptiveScore ? sig.adaptiveScore.toFixed(1) : 'N/A'}</div>
    <div class="signal-details">
      <div><strong>Entry:</strong> ${sig.entry.toFixed(4)}</div>
      <div><strong>TP:</strong> ${sig.tp.toFixed(4)}</div>
      <div><strong>SL:</strong> ${sig.sl.toFixed(4)}</div>
      <div><strong>RR:</strong> 1:${sig.rr.toFixed(2)}</div>
      <div><strong>Trend:</strong> ${sig.trend} (${sig.trendStrength.toFixed(1)}%)</div>
      <div><strong>Volume:</strong> ${sig.volumeConfirmation}</div>
      <div><strong>Retrace:</strong> ${sig.retracement.isRetracement ? (sig.retracement.completion * 100).toFixed(1) + '%' : 'No'}</div>
      <div><strong>FVG:</strong> ${sig.fvGaps}</div>
      <div><strong>Strategy:</strong> ${sig.strategy}</div>
      <div><strong>Adaptive Score:</strong> ${sig.adaptiveScore ? sig.adaptiveScore.toFixed(1) : 'N/A'}</div>
      <div><strong>Position Size:</strong> ${sig.positionSize ? '$' + sig.positionSize.toFixed(2) : 'N/A'}</div>
      <div><strong>Time:</strong> ${new Date().toLocaleString()}</div>
    </div>
  `;

  div.style.transform = 'translateY(-20px)';
  div.style.opacity = '0';
  
  container.prepend(div);
  
  setTimeout(() => {
    div.style.transition = 'all 0.5s ease';
    div.style.transform = 'translateY(0)';
    div.style.opacity = '1';
  }, 10);

  const cards = container.querySelectorAll('.signal-card');
  if (cards.length > 20) {
    cards[cards.length - 1].remove();
  }
}

function logTrade(symbol, sig){
  const tbody = document.querySelector("#trade-log tbody");
  const tr = document.createElement("tr");
  tr.innerHTML = `
    <td>${new Date().toLocaleString()}</td>
    <td>${symbol}</td>
    <td>${sig.signal}</td>
    <td>${sig.entry.toFixed(5)}</td>
    <td>${sig.tp.toFixed(5)}</td>
    <td>${sig.sl.toFixed(5)}</td>
    <td>1:${sig.rr.toFixed(2)}</td>
    <td>${sig.confidence.toFixed(1)}%</td>
    <td>${sig.marketRegime || 'N/A'}</td>
    <td>${sig.trend || 'N/A'}</td>
    <td>${sig.volumeConfirmation || 'N/A'}</td>
    <td>${sig.patterns.join(', ') || 'None'}</td>
    <td>${sig.strategy || 'N/A'}</td>
    <td>${sig.adaptiveScore ? sig.adaptiveScore.toFixed(1) : 'N/A'}</td>
    <td>OPEN</td>
  `;
  tbody.prepend(tr);
}

// NEW: Log closed trades
function logTradeClose(trade) {
  const tbody = document.querySelector("#trade-log tbody");
  const tr = document.createElement("tr");
  tr.innerHTML = `
    <td>${trade.openTime.toLocaleString()}</td>
    <td>${document.getElementById("symbol").value.toUpperCase()}</td>
    <td>${trade.signal}</td>
    <td>${trade.entry.toFixed(5)}</td>
    <td>${trade.tp.toFixed(5)}</td>
    <td>${trade.sl.toFixed(5)}</td>
    <td>1:${trade.rr ? trade.rr.toFixed(2) : '0'}</td>
    <td>${trade.confidence.toFixed(1)}%</td>
    <td>${trade.marketRegime || 'N/A'}</td>
    <td>${trade.trend || 'N/A'}</td>
    <td>${trade.volumeConfirmation || 'N/A'}</td>
    <td>${trade.patterns.join(', ') || 'None'}</td>
    <td>${trade.strategy || 'N/A'}</td>
    <td>${trade.adaptiveScore ? trade.adaptiveScore.toFixed(1) : 'N/A'}</td>
    <td style="color: ${trade.result === 'TP HIT' ? '#00ff00' : '#ff4444'}">${trade.result} (${trade.plPercent ? trade.plPercent.toFixed(2) + '%' : '0%'})</td>
  `;
  tbody.prepend(tr);
}

function updateChart(){
  if(candleBuffer.length === 0) return;
  
  try {
    const lastSig = generateEnhancedSignal(candleBuffer, document.getElementById("risk-level").value, parseFloat(document.getElementById("tp-multiplier").value) );
    const times = candleBuffer.map(c => new Date(c.time));
    const opens = candleBuffer.map(c => c.open);
    const highs = candleBuffer.map(c => c.high);
    const lows = candleBuffer.map(c => c.low);
    const closes = candleBuffer.map(c => c.close);

    const traceCandles = { x: times, open: opens, high: highs, low: lows, close: closes, type: "candlestick", name: "Candles" };
    const traceEntry = { x: [times[times.length-1]], y: [lastSig.entry], name: "Entry", mode: "lines+markers", line: { color: "yellow", width: 2 } };
    const traceTP = { x: [times[times.length-1]], y: [lastSig.tp], name: "TP", mode: "lines", line: { color: "green", width: 2, dash: "dot" } };
    const traceSL = { x: [times[times.length-1]], y: [lastSig.sl], name: "SL", mode: "lines", line: { color: "red", width: 2, dash: "dot" } };

    // Add EMA200 to chart
    const ema200 = EMA(candleBuffer, 200);
    const traceEMA200 = { x: times, y: ema200, name: "EMA200", mode: "lines", line: { color: "purple", width: 1 } };

    const fib = fibonacciLevels(candleBuffer);
    const shapes = [
      { type:"rect", xref:"x", yref:"y", x0: times[0], x1: times[times.length-1], y0: fib["0.382"]||0, y1: fib["0.618"]||0, fillcolor:"rgba(0,255,255,0.08)", line:{width:0} },
      { type:"rect", xref:"x", yref:"y", x0: times[0], x1: times[times.length-1], y0: fib["0.236"]||0, y1: fib["0.382"]||0, fillcolor:"rgba(0,255,255,0.04)", line:{width:0} },
      { type:"rect", xref:"x", yref:"y", x0: times[0], x1: times[times.length-1], y0: fib["0.618"]||0, y1: fib["0.786"]||0, fillcolor:"rgba(0,255,255,0.04)", line:{width:0} }
    ];

    // Add ORB levels to chart if available
    if (currentORBLevels) {
      shapes.push(
        { type:"line", xref:"paper", yref:"y", x0: 0, x1: 1, y0: currentORBLevels.ORH, y1: currentORBLevels.ORH, line: { color: "orange", width: 2, dash: "dot" } },
        { type:"line", xref:"paper", yref:"y", x0: 0, x1: 1, y0: currentORBLevels.ORL, y1: currentORBLevels.ORL, line: { color: "orange", width: 2, dash: "dot" } }
      );
    }

    Plotly.react("chart", [traceCandles, traceEntry, traceTP, traceSL, traceEMA200], { 
      margin:{t:30}, 
      paper_bgcolor: "#0d0d0d", 
      plot_bgcolor: "#0d0d0d", 
      font:{color:"#fff"}, 
      shapes,
      title: `Market Regime: ${lastSig.marketRegime || 'N/A'} | Trend: ${lastSig.trend || 'N/A'} | Strategy: ${lastSig.strategy || 'N/A'} | Candles: ${candleBuffer.length}`
    });
  } catch (error) {
    logError(error, 'Chart Update');
  }
}

function unlockSignal(){
  lastSignal = null;
  document.getElementById("unlock-btn").style.display = "none";
  document.getElementById("status").textContent = "RUNNING";
}

/* -------------------------
   BACKTEST FUNCTION (FIXED)
   ------------------------- */
async function runBacktest(){
  const symbol = document.getElementById("symbol").value.toUpperCase();
  const interval = document.getElementById("timeframe").value;
  const risk = document.getElementById("risk-level").value;
  const tpMultiplier = parseFloat(document.getElementById("tp-multiplier").value);
  const strategy = document.getElementById("trading-strategy").value;
  const exchange = document.getElementById("exchange").value;

  document.getElementById("backtest-results").style.display = "block";
  document.getElementById("backtest-results").innerHTML = `<div>Running adaptive backtest for <b>${symbol}</b> using ${strategy} strategy... (this may take a few seconds)</div>`;

  let limit = 500;
  
  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 30000);
    
    const endpoints = getExchangeEndpoints(exchange, symbol, interval);
    const res = await fetch(endpoints.historical, {
      signal: controller.signal
    });
    clearTimeout(timeoutId);
    
    const raw = await res.json();
    const rawData = raw.data || raw;
    if(!Array.isArray(rawData) || rawData.length === 0) throw new Error("Bad response");
    const candles = rawData.map(k => parseCandleData(exchange, k));

    let trades = [];
    const lookaheadBars = 12;
    
    // Reset ORB levels for backtest
    currentORBLevels = null;
    
    // 🔧 FIX: Start from 50 to ensure enough data for indicators
    for(let i = 50; i < candles.length - lookaheadBars; i++){ 
      const slice = candles.slice(0, i+1);
      
      // 🔧 FIX: Use a simplified signal generation for backtest to avoid trend confirmation issues
      const sig = generateBacktestSignal(slice, risk, tpMultiplier, strategy);
      
      if(!sig || sig.signal === "HOLD") continue;

      let hit = null;
      let exitPrice = sig.entry; // Default to entry if no hit
      let resultType = "NO_HIT";
      
      // Check for TP/SL hits in lookahead period
      for(let j = 1; j <= lookaheadBars && (i + j) < candles.length; j++){
        const future = candles[i + j];
        
        if(sig.signal === "BUY"){
          if(future.high >= sig.tp){ 
            hit = { type:'tp', price: sig.tp, bar: i+j }; 
            break; 
          }
          if(future.low <= sig.sl){ 
            hit = { type:'sl', price: sig.sl, bar: i+j }; 
            break; 
          }
        } else if (sig.signal === "SELL") {
          if(future.low <= sig.tp){ 
            hit = { type:'tp', price: sig.tp, bar: i+j }; 
            break; 
          }
          if(future.high >= sig.sl){ 
            hit = { type:'sl', price: sig.sl, bar: i+j }; 
            break; 
          }
        }
      }

      if(hit){
        exitPrice = hit.price;
        resultType = hit.type === 'tp' ? 'WIN' : 'LOSS';
      } else {
        // If no hit in lookahead, use the last available price
        exitPrice = candles[Math.min(i + lookaheadBars, candles.length - 1)].close;
        
        // Determine result based on final price vs entry
        if(sig.signal === "BUY") {
          resultType = exitPrice > sig.entry ? 'WIN' : 'LOSS';
        } else {
          resultType = exitPrice < sig.entry ? 'WIN' : 'LOSS';
        }
      }

      let pnl = sig.signal === "BUY" ? exitPrice - sig.entry : sig.entry - exitPrice;
      const pnlPercent = (pnl / sig.entry) * 100;
      
      trades.push({ 
        time: new Date(candles[i].time).toLocaleString(), 
        signal: sig.signal, 
        entry: sig.entry, 
        tp: sig.tp, 
        sl: sig.sl, 
        exit: exitPrice, 
        pnl, 
        pnlPercent,
        result: resultType, 
        confidence: sig.confidence,
        marketRegime: sig.marketRegime,
        trend: sig.trend,
        volumeConfirmation: sig.volumeConfirmation,
        patterns: sig.patterns?.join(', ') || 'None',
        strategy: sig.strategy,
        adaptiveScore: sig.adaptiveScore
      });
    }

    // 🔧 FIX: Handle case when no trades are generated
    if (trades.length === 0) {
      document.getElementById("backtest-results").innerHTML = `
        <h3>📊 Adaptive Backtest Results (${symbol})</h3>
        <div style="color: #ffaa33; text-align: center; padding: 20px;">
          <h4>⚠️ No Trades Generated</h4>
          <p>The backtest completed but no trading signals were generated.</p>
          <p>This could be due to:</p>
          <ul style="text-align: left; display: inline-block;">
            <li>Strict trend confirmation settings</li>
            <li>Market conditions not meeting strategy criteria</li>
            <li>Insufficient confidence levels</li>
          </ul>
          <p>Try adjusting the risk level or using a different strategy.</p>
        </div>
      `;
      return;
    }

    // Calculate basic metrics
    const wins = trades.filter(t => t.result === 'WIN').length;
    const losses = trades.filter(t => t.result === 'LOSS').length;
    const totalTrades = trades.length;
    const winRate = totalTrades ? (wins / totalTrades * 100).toFixed(1) : 0;
    const totalPnl = trades.reduce((a, t) => a + t.pnl, 0);
    const avgPnl = totalTrades ? totalPnl / totalTrades : 0;
    
    const winningTrades = trades.filter(t => t.result === 'WIN');
    const losingTrades = trades.filter(t => t.result === 'LOSS');
    
    const avgWin = winningTrades.length ? winningTrades.reduce((a, t) => a + t.pnl, 0) / winningTrades.length : 0;
    const avgLoss = losingTrades.length ? losingTrades.reduce((a, t) => a + t.pnl, 0) / losingTrades.length : 0;
    
    const profitFactor = avgLoss !== 0 ? Math.abs(avgWin / avgLoss) : avgWin > 0 ? 999 : 0;
    
    // Strategy performance breakdown
    const strategyStats = {};
    trades.forEach(trade => {
      const strat = trade.strategy;
      if (!strategyStats[strat]) {
        strategyStats[strat] = { wins: 0, losses: 0, total: 0, pnl: 0 };
      }
      strategyStats[strat].total++;
      if (trade.result === 'WIN') strategyStats[strat].wins++;
      else strategyStats[strat].losses++;
      strategyStats[strat].pnl += trade.pnl;
    });

    let strategyBreakdown = '';
    for (const [strat, stats] of Object.entries(strategyStats)) {
      const winRate = stats.total ? ((stats.wins / stats.total) * 100).toFixed(1) : 0;
      strategyBreakdown += `<div class="stat">
        <strong>${strat}</strong>
        <div>${stats.wins}W/${stats.losses}L (${winRate}%)</div>
        <div style="color: ${stats.pnl >= 0 ? '#00ff00' : '#ff4444'}">${stats.pnl.toFixed(4)}</div>
      </div>`;
    }

    // Display results
    document.getElementById("backtest-results").innerHTML = `
      <h3>📊 Adaptive Backtest Results (${symbol})</h3>
      <div style="display: flex; flex-wrap: wrap; gap: 15px; margin: 20px 0;">
        <div class="stat">
          <strong>Total Trades</strong>
          <div>${totalTrades}</div>
        </div>
        <div class="stat">
          <strong>Win Rate</strong>
          <div>${winRate}%</div>
        </div>
        <div class="stat">
          <strong>Total P&L</strong>
          <div style="color: ${totalPnl >= 0 ? '#00ff00' : '#ff4444'}">${totalPnl.toFixed(4)}</div>
        </div>
        <div class="stat">
          <strong>Avg P&L</strong>
          <div style="color: ${avgPnl >= 0 ? '#00ff00' : '#ff4444'}">${avgPnl.toFixed(4)}</div>
        </div>
        <div class="stat">
          <strong>Profit Factor</strong>
          <div>${profitFactor.toFixed(2)}</div>
        </div>
        <div class="stat">
          <strong>Avg Win</strong>
          <div style="color: #00ff00">${avgWin.toFixed(4)}</div>
        </div>
        <div class="stat">
          <strong>Avg Loss</strong>
          <div style="color: #ff4444">${avgLoss.toFixed(4)}</div>
        </div>
      </div>
      
      <h4>Strategy Performance Breakdown</h4>
      <div style="display: flex; flex-wrap: wrap; gap: 15px; margin: 20px 0;">
        ${strategyBreakdown}
      </div>

      <h4>Trade Details</h4>
      <div style="max-height: 400px; overflow-y: auto;">
        <table style="width: 100%; font-size: 12px; border-collapse: collapse;">
          <thead>
            <tr style="background: #333;">
              <th style="padding: 8px; border: 1px solid #555;">Time</th>
              <th style="padding: 8px; border: 1px solid #555;">Signal</th>
              <th style="padding: 8px; border: 1px solid #555;">Entry</th>
              <th style="padding: 8px; border: 1px solid #555;">Exit</th>
              <th style="padding: 8px; border: 1px solid #555;">P&L</th>
              <th style="padding: 8px; border: 1px solid #555;">Confidence</th>
              <th style="padding: 8px; border: 1px solid #555;">Strategy</th>
              <th style="padding: 8px; border: 1px solid #555;">Adaptive Score</th>
              <th style="padding: 8px; border: 1px solid #555;">Result</th>
            </tr>
          </thead>
          <tbody>
            ${trades.map(t => `
              <tr>
                <td style="padding: 6px; border: 1px solid #555;">${t.time}</td>
                <td style="padding: 6px; border: 1px solid #555;">${t.signal}</td>
                <td style="padding: 6px; border: 1px solid #555;">${t.entry.toFixed(4)}</td>
                <td style="padding: 6px; border: 1px solid #555;">${t.exit.toFixed(4)}</td>
                <td style="padding: 6px; border: 1px solid #555; color: ${t.pnl >= 0 ? '#00ff00' : '#ff4444'}">${t.pnl.toFixed(4)}</td>
                <td style="padding: 6px; border: 1px solid #555;">${t.confidence.toFixed(1)}%</td>
                <td style="padding: 6px; border: 1px solid #555;">${t.strategy}</td>
                <td style="padding: 6px; border: 1px solid #555;">${t.adaptiveScore ? t.adaptiveScore.toFixed(1) : 'N/A'}</td>
                <td style="padding: 6px; border: 1px solid #555; color: ${t.result === 'WIN' ? '#00ff00' : '#ff4444'}">${t.result}</td>
              </tr>
            `).join('')}
          </tbody>
        </table>
      </div>
    `;
    
  } catch (error) {
    logError(error, 'Backtest');
    document.getElementById("backtest-results").innerHTML = `<div style="color: #ff4444">Error running backtest: ${error.message}</div>`;
  }
}

// 🔧 NEW: Simplified backtest signal generation
function generateBacktestSignal(data, riskLevel, tpMultiplier, strategy) {
  if(!data || data.length < 50) return { 
    signal:"HOLD", 
    entry: data.length > 0 ? data[data.length-1].close : 0, 
    tp: 0, sl: 0, confidence:0, rr: 0,
    marketRegime: "NEUTRAL", trend: "NEUTRAL", volumeConfirmation: "N/A",
    strategy: strategy, adaptiveScore: 0
  };

  const last = data[data.length-1];
  const lastClose = last.close;

  // Use simplified trend detection for backtest
  const trendAnalysis = detectTrendType(data);
  const volumeAnalysis = volumeConfirmation(data);
  const rsi = advancedRSI(data);
  const currentRsi = rsi[rsi.length-1];

  let signal = "HOLD";
  let confidence = 0;
  let finalStrategy = strategy;

  // Simplified signal logic for backtest
  if (strategy === "auto") {
    // Auto strategy selection for backtest
    const marketConditions = analyzeMarketConditions(data);
    if (marketConditions) {
      const strategySelection = adaptiveStrategySelection(data);
      finalStrategy = strategySelection.strategy;
    }
  }

  // Generate basic signals based on RSI and trend
  if (currentRsi !== null) {
    if (currentRsi < 30 && trendAnalysis.direction === "UP") {
      signal = "BUY";
      confidence = 70;
    } else if (currentRsi > 70 && trendAnalysis.direction === "DOWN") {
      signal = "SELL";
      confidence = 70;
    } else if (currentRsi < 35 && trendAnalysis.strength > 30) {
      signal = "BUY";
      confidence = 65;
    } else if (currentRsi > 65 && trendAnalysis.strength > 30) {
      signal = "SELL";
      confidence = 65;
    }
  }

  // If no signal from RSI, try moving average crossover
  if (signal === "HOLD" && data.length > 20) {
    const sma20 = SMA(data, 20);
    const sma50 = SMA(data, 50);
    
    if (sma20[sma20.length-1] && sma50[sma50.length-1]) {
      if (sma20[sma20.length-1] > sma50[sma50.length-1] && lastClose > sma20[sma20.length-1]) {
        signal = "BUY";
        confidence = 60;
      } else if (sma20[sma20.length-1] < sma50[sma50.length-1] && lastClose < sma20[sma20.length-1]) {
        signal = "SELL";
        confidence = 60;
      }
    }
  }

  // Calculate TP/SL only if we have a signal
  let entry = lastClose;
  let tp = lastClose;
  let sl = lastClose;
  let rr = 0;

  if (signal !== "HOLD" && confidence >= 60) {
    entry = lastClose;
    sl = smartStopLoss(data, signal, confidence);
    const risk = Math.max(Math.abs(entry - sl), entry * 0.002);
    tp = signal === "BUY" ? entry + (risk * tpMultiplier) : entry - (risk * tpMultiplier);
    rr = tpMultiplier;
  } else {
    signal = "HOLD";
    confidence = 0;
  }

  return { 
    signal,
    entry,
    tp,
    sl,
    confidence,
    rr,
    marketRegime: trendAnalysis.trend,
    trend: trendAnalysis.trend,
    volumeConfirmation: volumeAnalysis.strength,
    patterns: [],
    strategy: finalStrategy,
    adaptiveScore: confidence > 0 ? confidence * 1.1 : 0
  };
}

// Initialize the bot
document.addEventListener('DOMContentLoaded', function() {
  console.log('🚀 Adaptive Trading Signal Bot Initialized');
  document.getElementById("status").textContent = "READY";
  document.getElementById("status").style.color = "#ffaa33";
  
  // Initialize performance metrics
  performanceMetrics.startTime = Date.now();
  
  // Set up periodic health checks
  setInterval(updatePerformanceMetrics, 10000);
});

/* -------------------------
   ADDITIONAL STYLING FOR ANIMATIONS
   ------------------------- */
const style = document.createElement('style');
style.textContent = `
  .regime-trending { color: #00ff00; }
  .regime-ranging { color: #ffff00; }
  .regime-volatile { color: #ff0000; }
  .regime-neutral { color: #cccccc; }

  .trend-uptrend { color: #00ff00; }
  .trend-downtrend { color: #ff4444; }
  .trend-ranging { color: #ffff00; }
  .trend-neutral { color: #cccccc; }

  .profit { color: #00ff00; }
  .loss { color: #ff0000; }

  @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
  }

  .analysis-card {
      transition: all 0.3s ease;
  }

  .analysis-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
  }
`;
document.head.appendChild(style);
</script>
</body>
</html>
